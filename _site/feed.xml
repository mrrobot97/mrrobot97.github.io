<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Mrrobot</title>
    <description>Record my study in android.</description>
    <link>http://mrrobot97.github.io/</link>
    <atom:link href="http://mrrobot97.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Tue, 22 Mar 2016 13:33:30 +0800</pubDate>
    <lastBuildDate>Tue, 22 Mar 2016 13:33:30 +0800</lastBuildDate>
    <generator>Jekyll v3.1.2</generator>
    
      <item>
        <title>Android反编译教程</title>
        <description>&lt;p&gt;本博客转自Android大神郭霖&lt;a href=&quot;http://blog.csdn.net/guolin_blog/article/details/49738023&quot;&gt;Android安全攻防战，反编译与混淆技术完全解析（上）&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;blockquote&gt;
  &lt;p&gt;之前一直有犹豫过要不要写这篇文章，毕竟去反编译人家的程序并不是什么值得骄傲的事情。不过单纯从技术角度上来讲，掌握反编译功能确实是一项非常有用的技能，可能平常不太会用得到，但是一旦真的需要用到的了，而你却不会的话，那就非常头疼了。另外既然别人可以反编译程序，我们当然有理由应该对程序进行一定程度的保护，因此代码混淆也是我们必须要掌握的一项技术。那么最近的两篇文章我们就围绕反编译和混淆这两个主题来进行一次完全解析。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;section&quot;&gt;反编译&lt;/h1&gt;

&lt;p&gt;我们都知道，Android程序打完包之后得到的是一个APK文件，这个文件是可以直接安装到任何Android手机上的，我们反编译其实也就是对这个APK文件进行反编译。Android的反编译主要又分为两个部分，一个是对代码的反编译，一个是对资源的反编译，我们马上来逐个学习一下。 
在开始学习之前，首先我们需要准备一个APK文件，为了尊重所有开发者，我就不拿任何一个市面上的软件来演示了，而是自己写一个Demo用来测试。 
这里我希望代码越简单越好，因此我们建立一个新项目，在Activity里加入一个按钮，当点击按钮时弹出一个Toast，就这么简单，代码如下所示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Button button = (Button) findViewById(R.id.button);
        button.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                Toast.makeText(MainActivity.this, &quot;you clicked button&quot;, Toast.LENGTH_SHORT).show();
            }
        });
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;activity_main.xml中的资源如下所示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;RelativeLayout&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;xmlns:android=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://schemas.android.com/apk/res/android&quot;&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;android:layout_width=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;match_parent&quot;&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;android:layout_height=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;match_parent&quot;&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;android:paddingBottom=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;@dimen/activity_vertical_margin&quot;&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;android:paddingLeft=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;@dimen/activity_horizontal_margin&quot;&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;android:paddingRight=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;@dimen/activity_horizontal_margin&quot;&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;android:paddingTop=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;@dimen/activity_vertical_margin&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;nt&quot;&gt;&amp;lt;Button&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;android:id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;@+id/button&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;android:layout_width=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;wrap_content&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;android:layout_height=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;wrap_content&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;android:text=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Button&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;&amp;lt;/RelativeLayout&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后我们将代码打成一个APK包，并命名成Demo.apk，再把它安装到手机上，结果如下所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160204142511216&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;好的，到这里准备工作就已经基本完成了，接下来就让我们开始对这个Demo程序进行反编译吧。
# 反编译代码
要想将APK文件中的代码反编译出来，我们需要用到以下两款工具：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;dex2jar 这个工具用于将dex文件转换成jar文件&lt;/p&gt;

    &lt;p&gt;下载地址：http://sourceforge.net/projects/dex2jar/files/&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;jd-gui 这个工具用于将jar文件转换成java代码&lt;/p&gt;

    &lt;p&gt;下载地址：http://jd.benow.ca/&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;将这两个工具都下载好并解压，然后我们就开始对Demo程序进行反编译。解压dex2jar压缩包后，你会发现有很多个文件，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160204153609614&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中我们要用到的是d2j-dex2jar.bat这个文件，当然如果你是linux或mac系统的话就要用d2j-dex2jar.sh这个文件。 
然后我们将Demo.apk文件也进行解压，如果不知道怎么直接解压的可以先将文件重命名成Demo.zip，然后用解压软件打开。解压之后你会发现里面有一个classes.dex文件，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160204160337530&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个classes.dex文件就是存放所有java代码的地方了，我们将它拷贝到dex2jar解压后的目录下，并在cmd中也进入到同样的目录，然后执行：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;d2j-dex2jar classes.dex
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;执行结果如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160204160725801&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;没有报任何错误，这就说明我们已经转换成功了。现在观察dex2jar目录，你会发现多了一个文件，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160204161831426&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到，classes-dex2jar.jar这个文件就是我们借助工具之后成功转换出来的jar文件了。但是对于我们而言，jar文件也不是可读的，因此这里还需要再借助一下jd-gui这个工具来将jar文件转换成java代码。 
下面就很简单了，使用jd-gui工具打开classes-dex2jar.jar这个文件，结果如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160204162548914&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;OK，由此可见，我们的代码反编译工作已经成功了，MainActivity中的代码非常清晰，基本已经做到了90%以上的还原工作。但是如果想要做到100%的代码还原还是非常有难度的，因为像setContentView()方法传入的参数，其实就是一个资源的id值而已，那么这里反编译也就只能将相应的id值进行还原，而无法变成像R.layout.activity_main这样直观的代码展示。 
另外，除了MainActivity之外，还有很多其它的代码也被反编译出来了，因为当前项目有引用support-v4和support-v7的包，这些引用的library也会作为代码的一部分被打包到classes.dex文件当中，因此反编译的时候这些代码也会一起被还原。 
好的，学完了反编译代码，接下来我们看一下如何反编译资源。&lt;/p&gt;

&lt;h1 id=&quot;section-1&quot;&gt;反编译资源&lt;/h1&gt;

&lt;p&gt;其实细心的朋友可能已经观察到了，刚才Demo.apk的解压目录当中不是已经有资源文件了吗，有AndroidManifest.xml文件，也有res目录。进入res目录当中，内容如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160205114006588&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这不是所有资源文件都在这里了么？其实这些资源文件都是在打包的时候被编译过了，我们直接打开的话是看不到明文的，不信的话我们打开AndroidManifest.xml文件来瞧一瞧，内容如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160205114422374&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到，这代码是完全没法阅读的。当然如果你去打开activity_main.xml看看，结果也不会好到哪儿去：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160205114648290&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;由此可见，直接对APK包进行解压是无法得到它的原始资源文件的，因此我们还需要对资源进行反编译才行。 
要想将APK文件中的资源反编译出来，又要用到另外一个工具了：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;apktool&lt;/strong&gt; 这个工具用于最大幅度地还原APK文件中的9-patch图片、布局、字符串等等一系列的资源。&lt;/p&gt;

    &lt;p&gt;下载地址：http://ibotpeaches.github.io/Apktool/install/&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;关于这个工具的下载我还要再补充几句，我们需要的就是apktool.bat和apktool.jar这两个文件。目前apktool.jar的最新版本是2.0.3，这里我就下载最新的了，然后将apktool_2.0.3.jar重命名成apktool.jar，并将它们放到同一个文件夹下就可以了，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160205125449076&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;接下来的工作就很简单了，我们将Demo.apk拷贝到和这两个文件同样的目录当中，然后cmd也进入到这个目录下，并在cmd中执行如下命令：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;apktool d Demo.apk
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中d是decode的意思，表示我们要对Demo.apk这个文件进行解码。那除了这个基本用法之外，我们还可以再加上一些附加参数来控制decode的更多行为：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;-f&lt;/strong&gt; 如果目标文件夹已存在，则强制删除现有文件夹（默认如果目标文件夹已存在，则解码失败）。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;-o&lt;/strong&gt; 指定解码目标文件夹的名称（默认使用APK文件的名字来命名目标文件夹）。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;-s&lt;/strong&gt; 不反编译dex文件，也就是说classes.dex文件会被保留（默认会将dex文件解码成smali文件）。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;-r&lt;/strong&gt; 不反编译资源文件，也就是说resources.arsc文件会被保留（默认会将resources.arsc解码成具体的资源文件）。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;常用用法就这么多了，那么上述命令的执行结果如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160205130623698&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这就说明反编译资源已经成功了。 
当然即使你在和我执行一模一样的操作，也有可能会在这里反编译失败，比如说会报如下错误：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160205131116809&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;出现这个错误的原因很有可能是你之前使用过apktool的老版本进行过反编译操作，然后apktool就会在你系统的 &lt;code class=&quot;highlighter-rouge&quot;&gt;C:\Users\Administrator\apktool\framework&lt;/code&gt; 这个目录下生成一个名字为 &lt;code class=&quot;highlighter-rouge&quot;&gt;1.apk&lt;/code&gt; 的缓存文件，将这个缓存文件删除掉，然后再重新执行反编译命令应该就可以成功了。&lt;/p&gt;

&lt;p&gt;现在你会发现在当前目录下多了一个Demo文件夹，这个文件夹中存放的就是反编译的结果了。我们可以打开AndroidManifest.xml来瞧一瞧，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160205184526870&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;怎么样？这样就完全能看得懂了吧，然后可以再到res/layout中看一下activity_main.xml文件，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160205185353442&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到，activity_main.xml中的内容基本和源代码中的内容是一致的，外层是一个RelativeLayout，里面则是一个Button。你可以再到其它目录中去看一看别的资源，基本上都是可以正常还原的，这样我们就把反编译资源的方法也已经掌握了。&lt;/p&gt;

&lt;h1 id=&quot;section-2&quot;&gt;重新打包&lt;/h1&gt;

&lt;p&gt;那么对于反编译出来的文件夹，我们能不能重新把它打包成APK文件呢？答案是肯定的，只不过我实在想不出有什么义正言辞的理由可以让我们这么做。有的人会说汉化，没错，汉化的方式确实就是将一个APK进行反编译，然后翻译其中的资源再重新打包，但是不管怎么说这仍然是将别人的程序进行破解，所以我并不认为这是什么光荣的事情。那么我们就不去讨论本身这件事情的对或错，这里只是站在技术的角度来学习一下重新打包的相关知识。 
首先我们来看一下通过apktool反编译后的包目录情况，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160208234027946&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中，original文件夹下存放的是未经反编译过、原始的AndroidManifest.xml文件，res文件夹下存放的是反编译出来的所有资源，smali文件夹下存放的是反编译出来的所有代码，AndroidManifest.xml则是经过反编译还原后的manifest文件。这里值得一提的是smali文件夹，如果你进入到这个文件夹中你会发现它的目录结构和我们源码中src的目录结构是几乎一样的，主要的区别就是所有的java文件都变成了smali文件。smali文件其实也是真正的源代码，只不过它的语法和java完全不同，它有点类似于汇编的语法，是Android虚拟机所使用的寄存器语言，语法结构大概如下所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160208235859750&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;看上去有点晕头转向是吗？但是如果你一旦能够看得懂smali文件的话，那么你就可以做很恐怖的事情了——你可以随意修改应用程序内的逻辑，将其进行破解！ 
不过我对这种黑技术并没有什么太大的兴趣，因此我也没有去做具体研究，但即使是这样，也已经可以对程序的逻辑做一定程度的修改了。比如说当我们点击按钮时会弹出&lt;code class=&quot;highlighter-rouge&quot;&gt;you clicked button&lt;/code&gt;这样一句Toast，逻辑是写在MainActivity按钮点击事件的匿名类当中的，因此这段代码反编译之后一定就会MainActivity$1.smali这个文件当中，让我们打开瞧一瞧，部分代码如下所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160209154620278&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;虽说多数的代码我是看不懂的，但其中第47行实在太明显了，Toast显示的内容不就是在这里定义的么，那么如果我们想把Demo程序hack掉，就可以将这段字符串给改掉，比如说我把它改成Your app is been hacked。 
关于smali的语法，网上的资料也非常多，如果你对这门技术十分感兴趣的话可以直接上网去搜，这里我只是简单介绍一下，就不再深入讲解相关知识了。 
改了一处代码后我们再来改一处资源吧，比如这里想要把Demo的应用图标给换掉，那么首先我们要准备好一张新的图片，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160209161422695&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后从AndroidManifest.xml文件中可以看出，应用图标使用的是ic_launcher.png这张图片，那么我们将上面篮球这张图片命名成ic_launcher.png，然后拷贝到所有以res/mipmap开头的文件夹当中完成替换操作。 
在做了两处改动之后，我们现在来把反编译后的Demo文件夹重新打包成APK吧，其实非常简单，只需要在cmd中执行如下命令：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;apktool b Demo -o New_Demo.apk
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中b是build的意思，表示我们要将Demo文件夹打包成APK文件，-o用于指定新生成的APK文件名，这里新的文件叫作New_Demo.apk。执行结果如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160209163551554&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;现在你会发现在同级目录下面生成了一个新的APK文件:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160209175505785&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;不过不要高兴得太早了，目前这个New_Demo.apk还是不能安装的，因为它还没有进行签名。那么如果这是别人的程序的话，我们从哪儿能拿到它原来的签名文件呢？很显然，这是根本没有办法拿到的，因此我们只能拿自己的签名文件来对这个APK文件重新进行签名，但同时也表明我们重新打包出来的软件就是个十足的盗版软件。这里大家学学技术就好了，希望不要有任何人去做什么坏事情。 
那么这里我就用一个之前生成好的签名文件了，使用Android Studio或者Eclipse都可以非常简单地生成一个签名文件。 
有了签名文件之后在cmd中执行签名命令就可以进行签名了，命令格式如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jarsigner -verbose -sigalg SHA1withRSA -digestalg SHA1 -keystore 签名文件名 -storepass 签名密码 待签名的APK文件名 签名的别名
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中jarsigner命令文件是存放在jdk的bin目录下的，需要将bin目录配置在系统的环境变量当中才可以在任何位置执行此命令。 
签名之后的APK文件现在已经可以安装到手机上了，不过在此之前Android还极度建议我们对签名后的APK文件进行一次对齐操作，因为这样可以使得我们的程序在Android系统中运行得更快。对齐操作使用的是zipalign工具，该工具存放于&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;Android SDK&amp;gt;/build-tools/&amp;lt;version&amp;gt;&lt;/code&gt;目录下，将这个目录配置到系统环境变量当中就可以在任何位置执行此命令了。命令格式如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;zipalign 4 New_Demo.apk New_Demo_aligned.apk
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中4是固定值不能改变，后面指定待对齐的APK文件名和对齐后的APK文件名。运行这段命令之后就会生成一个New_Demo_aligned.apk文件，如下所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160209175645990&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个New_Demo_aligned.apk就是我们重新打包签名对齐后的文件了，现在把它安装到手机上，效果如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160212105044897&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到，应用图标已经成功改成了篮球，另外点击按钮后弹出的Toast的提示也变成了我们修改后的文字，说明重新打包操作确实已经成功了。&lt;/p&gt;

</description>
        <pubDate>Tue, 22 Mar 2016 00:00:00 +0800</pubDate>
        <link>http://mrrobot97.github.io/Android%E5%8F%8D%E7%BC%96%E8%AF%91%E6%95%99%E7%A8%8B/</link>
        <guid isPermaLink="true">http://mrrobot97.github.io/Android%E5%8F%8D%E7%BC%96%E8%AF%91%E6%95%99%E7%A8%8B/</guid>
        
        
      </item>
    
      <item>
        <title>Loading Bitmap Efficiently</title>
        <description>&lt;h4 id=&quot;androidbitmapoomout-of-memorylistiewbitmap&quot;&gt;Android系统为每个程序都分配了一定的内存，当我们的程序加载比较大的bitmap时十分容易出现OOM(Out Of Memory)的错误，这种错尤其容易出现在用Listiew加载图片时。本篇文章讲述如何高效地加载一个Bitmap，即使其占用的内存足够小.&lt;/h4&gt;

&lt;p&gt;文章分析及实例代码来源于Google官方给的Training &lt;a href=&quot;http://developer.android.com/training/building-graphics.html&quot;&gt;Displaying Bitmaps Efficiently&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;首先我们获取要加载的图片的宽与高与图片类型，方法如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;BitmapFactory.Options options = new BitmapFactory.Options();
options.inJustDecodeBounds = true;
BitmapFactory.decodeResource(getResources(), R.id.myimage, options);
int imageHeight = options.outHeight;
int imageWidth = options.outWidth;
String imageType = options.outMimeType;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后通过比较图片实际的宽高与我们需要在屏幕上显示的大小，调整BitmapFactory.Options的inSampleSize,注意通过设置options.inJustDecodeBounds=true，我们可以只加载图片的大小和类型，而不会真正地将图片加载到内存中。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static int calculateInSampleSize(
            BitmapFactory.Options options, int reqWidth, int reqHeight) {
    // Raw height and width of image
    final int height = options.outHeight;
    final int width = options.outWidth;
    int inSampleSize = 1;

    if (height &amp;gt; reqHeight || width &amp;gt; reqWidth) {

        final int halfHeight = height / 2;
        final int halfWidth = width / 2;

        // Calculate the largest inSampleSize value that is a power of 2 and keeps both
        // height and width larger than the requested height and width.
        while ((halfHeight / inSampleSize) &amp;gt; reqHeight
                &amp;amp;&amp;amp; (halfWidth / inSampleSize) &amp;gt; reqWidth) {
            inSampleSize *= 2;
        }
    }

    return inSampleSize;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;options.inSampleSize是用来调整图片的压缩比例的，比如inSampleSize=2，就将图片的width和height分别设置为原图片的一半，这样压缩后的图片的体积就只有原来的1/4了。&lt;/p&gt;

&lt;p&gt;最后当我们获取到合适的inSampleSize后再将options.inJustDecodeBounds设置为true，就可以真正地将压缩后的图片加载到内存中去了。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static Bitmap decodeSampledBitmapFromResource(Resources res, int resId,
        int reqWidth, int reqHeight) {

    // First decode with inJustDecodeBounds=true to check dimensions
    final BitmapFactory.Options options = new BitmapFactory.Options();
    options.inJustDecodeBounds = true;
    BitmapFactory.decodeResource(res, resId, options);

    // Calculate inSampleSize
    options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight);

    // Decode bitmap with inSampleSize set
    options.inJustDecodeBounds = false;
    return BitmapFactory.decodeResource(res, resId, options);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Sun, 20 Mar 2016 00:00:00 +0800</pubDate>
        <link>http://mrrobot97.github.io/Loading-Bitmap-Efficiently/</link>
        <guid isPermaLink="true">http://mrrobot97.github.io/Loading-Bitmap-Efficiently/</guid>
        
        
      </item>
    
      <item>
        <title>Linux常用命令汇总</title>
        <description>&lt;p&gt;ls:
	-a 显示所有文件，包括隐藏
	-l 显示详细信息
	-d 查看目录属性
	-h 人性化显示文件大小，即单位为k,m,g
	-i 显示 inode
ll = ls -l&lt;/p&gt;

&lt;p&gt;mkdir -p [目录名]
	-p 递归创建 eg. mkdir test/test2&lt;/p&gt;

&lt;p&gt;ctrl+l 清屏&lt;/p&gt;

&lt;p&gt;cd - 进入上次目录&lt;/p&gt;

&lt;p&gt;命令 + 两次Tab键 : 提示&lt;/p&gt;

&lt;p&gt;rmdir 只能删除空目录(基本不用)&lt;/p&gt;

&lt;p&gt;rm 删除文件
	-r 删除文件夹
	-f 强制删除   故 rm -rf 强制删除文件或者目录&lt;/p&gt;

&lt;p&gt;cp 复制  cp  源文件  目的地 (可改名)
	-r 复制目录
	-p 连带文件属性复制
	-d 若源文件是链接文件，则赋值链接属性
	-a 相当于 -pdr ，即复制后的文件与源文件完全一样&lt;/p&gt;

&lt;p&gt;mv 剪切 用法与cp基本相同，只是剪切目录时不需要-r参数
 	mv命令还可以用来给文件更改名字  eg. mv asd dsa&lt;/p&gt;

&lt;p&gt;文件搜索命令：
locate + 文件名
	在后台数据库中按文件名搜索，搜索速度快，数据库位于  /var/lib/mlocate
	注意数据库不是实时更新的。
	updatedb  强制更新数据库&lt;/p&gt;

&lt;p&gt;find [搜索范围] 【搜索条件】
	-name  搜索结果必须与搜索条件完全一致  eg. find /home -name asd
	-iname 不区分大小写搜索
	-user 按照所有者搜索  eg. find /root -user root
	-nouser 查找没有所有者的文件 通常是垃圾文件
	-inum 根据inode查找文件 eg. find /root -inum 262421&lt;/p&gt;

&lt;p&gt;grep [选项] 字符串 文件名: 在文件中匹配符合条件的字符串
	-i 忽略大小写
	-v 排除指定字符串&lt;/p&gt;

&lt;p&gt;linux中的通配符：
	* 匹配任意内容
	？匹配任意一个·字符
	[] 匹配任意一个中括号内的字符&lt;/p&gt;

&lt;p&gt;命令搜索命令：
	whereis + 命令名
	-b 只查找可执行文件
	-m 只查找帮助文件
	不能搜索普通文件&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;which + 命令名：显示命令路径，若有别名则打印出别名.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;man + 命令 ：显示命令帮助手册&lt;/p&gt;

&lt;p&gt;help + 内部shell命令（如cd）  查看shell内部命令帮助  只能查看内部命令&lt;/p&gt;

&lt;p&gt;文件压缩与解压缩：
zip  压缩文件名 源文件 ：压缩单个文件
zip -r 压缩文件名 源目录 ：压缩目录&lt;/p&gt;

&lt;p&gt;unzip + 压缩文件：解压缩&lt;/p&gt;

&lt;p&gt;gzip 源文件： 压缩为.gz格式的压缩文件，源文件会消失
gzip -c 源文件  &amp;gt; 压缩文件 ：压缩为.gz格式，源文件会保留  //不常用&lt;/p&gt;

&lt;p&gt;gzip -r + 目录 ：压缩目录下的所有子文件，但是不压缩目录&lt;/p&gt;

&lt;p&gt;gzip -d 压缩文件： 解压缩
gunzip 压缩文件： 解压缩&lt;/p&gt;

&lt;p&gt;打包命令tar:
	tar -cvf 打包文件名 源文件
		-c 打包
		-v 显示过程
		-f 指定打包后的文件名
	tar -zcvf 
		：打包并压缩为.tar.gz格式
		末尾解参数 -C 路径  解压到指定路径
解包：
	tar -xvf 解压.tar并且显示过程
		-x: 解包
		-zxvf 解压缩并解包 .tar.gz文件&lt;/p&gt;

&lt;p&gt;关机、重启：
	shutdown [选项] 时间
		-c: 取消前一个关进命令
		-h: 关机
		-r: 重启&lt;/p&gt;

&lt;p&gt;挂载：
	mount : 查询系统中已经挂载的设备
	-a :根据配置文件/etc/fstab的内容，自动挂载&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mount [-t  文件系统] [-o 特殊选项] 设备文件名 挂载点

unmount 设备名或挂载点：卸载 fdisk -l :查看外设
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;用户操作：
	w/who 用户名：查看用户登陆信息
	last :系统所有用户登陆信息
	lastlog: 系统所有用户最后一次登陆信息&lt;/p&gt;

&lt;p&gt;输出重定向
	命令 &amp;amp;&amp;gt;文件 ：以覆盖的方式，将正确输出和错误输出都保存到文件中。
	命令 &amp;amp;»文件 ：以追加的方式，将正确输出和错误输出都保存到文件中。
	命令»文件1 2»文件2 ：把正确输出追加到文件1，把错误输出追加到文件2.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;常用快捷操作：  ctrl+c :强制终止当前命令  ctrl+l :清屏  ctrl+a :光标移动到命令行首  ctrl+e :光标移动到命令行尾  ctrl+u :从光标所在位置删除到行首  ctrl+z :把命令放入后台  ctrl+r :在历史命令中搜索
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;多命令执行：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;命令1 ； 命令2   ：两条命令之间没有任何逻辑顺序。
命令1 &amp;amp;&amp;amp; 命令2   ：命令1正确执行才会执行命令2，若命令1未正确执行，则不执行命令2.
命令1 || 命令2	：命令1执行失败才会执行命令2，若命令1正确执行，则不执行命令2.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;管道符
	命令1 | 命令2   ： 命令1的正确输出作为命令2的操作对象。&lt;/p&gt;

&lt;p&gt;查看本机启用的端口
	netstat:
		-a :查看所有连接的监听端口
		-n  :显示IP地址和端口号，而不显示域名和服务名&lt;/p&gt;

&lt;p&gt;配置网络：
网卡信息文件： vi /etc/sysconfig/network-scripts/ifcfg-eth0
DNS配置文件：	 vi /etc/resolv.conf&lt;/p&gt;

&lt;p&gt;ifconfig:	查看与临时配置网络
ifdown+网卡设备名：	禁用该网卡
ifup+网卡设备名：		启用该网卡
netstat 
	-t 列出TCP协议端口
	-u 列出TCP协议端口
	-n 不适用域名与服务名，而使用IP地址和端口号 
	-l 仅列出在监听状态的网络服务
	-a 列出所有网络连接&lt;/p&gt;

&lt;p&gt;wget + URL 下载文件&lt;/p&gt;

&lt;p&gt;tcpdump 抓包  使用方法见百度&lt;/p&gt;

&lt;p&gt;ssh远程登录：
	ssh 用户名@ip  远程登录指定linux服务器
	scp [-r] 用户名@ip:文件路径  本地路径    从指定ip出下载文件到本地 
	scp [-r] 本地文件 用户名@ip:上传路径   将本地文件上传至指定服务器&lt;/p&gt;

&lt;p&gt;rpm安装包的使用
	若操作的包是没有安装的，则安装时要使用包全名并且要注意路径。
	若操作的包是已经安装的，使用包名，因为所有安装过的rpm包都在 /var/lib/rpm下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rpm -ivh 包全名
	-i 安装
	-v 显示详细信息
	-h 显示进度
	- --nodeps 不检测依赖性（可能导致无法使用）
	-U 升级（包全名）

rpm -q 包名 ：查询是否安装包
rpm -qa:列出所有已经安装的rpm包
	-e 卸载 （包名）

rpm -qi 包名
	-i 查询软件信息
	-q 查询未安装包信息
rpm -qf 系统文件：查看系统文件属于哪个包
rpm -V 已安装的包名：校验rpm包
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;yum命令：
	yum list  查询yum源所有的软件包
	yum search 关键字：搜寻相关安装包
	yum -y install 包名：安装包
		-y :自动回答yes
	yum -y update 包名:升级包
	yum -y remove 包名：卸载包
	yum grouplist:查询组包
	yum groupinstall 软件组名：安装指定软件组
	yum groupremove 软件组名：卸载指定软件组&lt;/p&gt;

&lt;p&gt;安装源码包：
	1.解压源码包。
	2.进入解压后的源码包目录。
	3.执行 ./configure –prefix=安装目录(通常在/usr/local/下) 
		作用：定义需要的功能选项
			检测系统环境是否合安装要求
			把定义好的功能选项和检测系统环境的信息都写入MakeFile文件，用于后续的编辑。
	4.make编译
		make clean:清楚编译后的缓存文件
		make install:编译安装&lt;/p&gt;

&lt;p&gt;chmod  读写权限（755……） 文件名 ：更改文件权限
	-R :递归，适用于目录文件&lt;/p&gt;

&lt;p&gt;chown username filename ：更改文件所有者
chgro groupname filename:更改文件组所有者&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;						shell编程 &quot;$变量名&quot;字符 ：在原变量后追加字符	
eg:x=1
	y=&quot;$x&quot;2
	则 echo $y   将打印12
也可  ${变量名}字符    也是在变量后追加字符串
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;set :查询系统下所有已经生效的变量
	-u 当查询没定义的变量时，系统给出错误提示
unset 变量名 ：删除变量&lt;/p&gt;

&lt;p&gt;用户自定义环境变量
	export 变量名=变量值 或 变量名=变量值 然后 export 变量名
env 查看环境变量&lt;/p&gt;

&lt;p&gt;换行符 ： “&quot;   ，若一条命令太长可用换行符转到第二行接着打。&lt;/p&gt;

&lt;p&gt;预定义变量：
	$? ：最后一次执行命令的返回状态，如果这个值为0，则表明上一个命令执行正确；如果为非零，则表明上一条命令未能正确执行。
	$$ :返回当前进程的PID号&lt;/p&gt;

&lt;p&gt;read 命令：接收键盘输入&lt;/p&gt;

&lt;p&gt;declare [+/-] [参数] 变量名
	-：给变量设定类型属性		eg -i  声明为整形
	+：取消变量的类型属性&lt;/p&gt;

&lt;p&gt;数值运算：
	$((运算式)) 或 $[运算式]   eg: a=$(($b+$c))&lt;/p&gt;

&lt;p&gt;source + 配置文件 /   . + 配置文件 ：使对配置文件的修改立即生效而不用重启系统&lt;/p&gt;

&lt;p&gt;注意正则表达式与通配符的区别，两者是不同的概念。&lt;/p&gt;

&lt;p&gt;cut :提取字符串
	cut [选项] 文件名： 提取指定列 （默认以TAB及制表符分割列）
		-d ：自定义分隔符，默认为制表符。
		-f ：指定显示的列数&lt;/p&gt;

&lt;p&gt;awk   ‘条件1{动作1}条件2{动作2}条件3{动作三}……’
	当条件满足时，对应的动作就会执行
sed (Stream Editor)
	sed [选项] ‘[动作]’ 文件名&lt;/p&gt;

&lt;p&gt;排序命令 sort
	sort [选项] 文件名
		-f 忽略大小写
		-n 以数值型进行排序，默认使用字符串排序
		-r 反向排序
		-t 指定分隔符 默认是制表符
		-k [n,m] 按照指定的字段范围排序，从第n字段开始，第m字段结束&lt;/p&gt;

&lt;p&gt;wc [选项] 文件名：统计命令
	-l :只统计行数
	-w :只统计单词书
	-m :只统计字符数&lt;/p&gt;

&lt;p&gt;判断文件是否存在：
  [ 参数 + 文件名 ]&lt;/p&gt;
</description>
        <pubDate>Sat, 19 Mar 2016 00:00:00 +0800</pubDate>
        <link>http://mrrobot97.github.io/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/</link>
        <guid isPermaLink="true">http://mrrobot97.github.io/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/</guid>
        
        
      </item>
    
      <item>
        <title>android studio android annotations</title>
        <description>&lt;p&gt;在android studio 中配置android annotations.
按照如下代码注释中的分别在全局gradle和局部gradle中添加相应代码即可，留着自己备忘用。&lt;/p&gt;

&lt;p&gt;这是全局gradle的&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Top-level build file where you can add configuration options common to all sub-projects/modules.

buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath &#39;com.android.tools.build:gradle:1.3.0&#39;

        //annotations
        classpath &#39;com.neenbedankt.gradle.plugins:android-apt:1.8&#39;

        // NOTE: Do not place your application dependencies here; they belong
        // in the individual module build.gradle files
    }
}

allprojects {
    repositories {
        jcenter()
    }
}

task clean(type: Delete) {
    delete rootProject.buildDir
} 

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这是局部gradle的&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;apply plugin: &#39;com.android.application&#39;
//annotations
apply plugin: &#39;android-apt&#39;
def AAVersion = &#39;3.3.2&#39;

android {
    compileSdkVersion 23
    buildToolsVersion &quot;23.0.2&quot;

    defaultConfig {
        applicationId &quot;com.mrrobot.annotations&quot;
        minSdkVersion 16
        targetSdkVersion 23
        versionCode 1
        versionName &quot;1.0&quot;
    }
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39;
        }
    }
}

//annotations
apt {
    arguments {
        androidManifestFile variant.outputs[0]?.processResources?.manifestFile

    }
}

dependencies {
    compile fileTree(dir: &#39;libs&#39;, include: [&#39;*.jar&#39;])
    testCompile &#39;junit:junit:4.12&#39;
    compile &#39;com.android.support:appcompat-v7:23.1.1&#39;

    //annotations
    apt &quot;org.androidannotations:androidannotations:$AAVersion&quot;
    compile &quot;org.androidannotations:androidannotations-api:$AAVersion&quot;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Sat, 19 Mar 2016 00:00:00 +0800</pubDate>
        <link>http://mrrobot97.github.io/android-studio-android-annotations/</link>
        <guid isPermaLink="true">http://mrrobot97.github.io/android-studio-android-annotations/</guid>
        
        
      </item>
    
      <item>
        <title>First blog</title>
        <description>&lt;p&gt;This is my first blog espacially designed for recording my sduty in android development.&lt;/p&gt;

&lt;p&gt;Mrrobot - an android developer.&lt;/p&gt;

&lt;p&gt;Start from today.&lt;/p&gt;
</description>
        <pubDate>Fri, 18 Mar 2016 00:00:00 +0800</pubDate>
        <link>http://mrrobot97.github.io/first-blog/</link>
        <guid isPermaLink="true">http://mrrobot97.github.io/first-blog/</guid>
        
        
      </item>
    
  </channel>
</rss>
