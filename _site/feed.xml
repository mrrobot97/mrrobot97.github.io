<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>mrrobot97&#39;s blog</title>
    <description>Record my study in android.</description>
    <link>http://mrrobot97.github.io/</link>
    <atom:link href="http://mrrobot97.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 06 Mar 2017 20:37:10 +0800</pubDate>
    <lastBuildDate>Mon, 06 Mar 2017 20:37:10 +0800</lastBuildDate>
    <generator>Jekyll v3.1.2</generator>
    
      <item>
        <title>自己写一个简易版本的EventBus</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;大名鼎鼎的&lt;a href=&quot;https://github.com/greenrobot/EventBus&quot;&gt;EventBus&lt;/a&gt;很多人一定都用过，这个框架通过利用注解+反射，很好的实现了事件订阅者与发布者的解耦。今天我们就手动实现一个简易版本的EventBus。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;先写我们的EventBus类，模仿真正的EventBus类，我们这个类里面包含的也是标准的几个方法:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.void register(Object subscriber)
2.void unregister(Object subscriber)
3.void post(Object eventType)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;EventBus里的方法只有这几个（因为我们是简易版本的嘛）。当然我们的EventBus是一个单例模式类，我用的是双重检测null的那种：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private static EventBus defaultInstance;

public static EventBus getDefault(){
        if(defaultInstance==null){
            synchronized (EventBus.class){
                if(defaultInstance==null) defaultInstance=new EventBus();
            }
        }
        return defaultInstance;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;接下来是一个很重要的成员变量:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private HashMap&amp;lt;Class&amp;lt;?&amp;gt;,ArrayList&amp;lt;Subscription&amp;gt;&amp;gt; subscriptionsByEventType=new HashMap&amp;lt;&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;解释一下：HashMap的key为Class对象，其实就是订阅者中各种onEvent*函数的参数的Class对象，用过EventBus的都知道我们可以利用不同的参数对象实现不同事件的订阅。而HashMap的value是一个ArrayList,其中就是存储针对不同的参数对象的订阅。利用这个HashMap，可以轻易地找到所有订阅某一参数类型事件的所有订阅者。订阅信息就包含在类Subscription中。&lt;/p&gt;

&lt;p&gt;我们分析一下Subscription类中应该包含哪些信息:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.事件的订阅者，即subscriber。
2.订阅的事件,即method。
3.事件应该发生的线程，即ThreadMode。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;综上，我们的类Subscription如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Subscription {
    public Method method;
    public Object subscriber;
    public ThreadMode mode;

    public Subscription(Method method, Object subscriber, ThreadMode mode) {
        this.method = method;
        this.subscriber = subscriber;
        this.mode = mode;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中ThreadMode就是一个简单的枚举，作为演示我只设置了两个值:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public enum ThreadMode {
    MainThread,PostThread
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;即post事件所在的线程以及主线程main。&lt;/p&gt;

&lt;p&gt;EventBus的成员变量暂时就这些，还有一个稍后再讲，接下来就是成员方法的实现，我们一个一个来，首先是register方法。先看一下register的全部代码:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void register(Object subscriber){
        //根据反射机制，查找subscriber中所有已onEvent开头的method
        Class&amp;lt;?&amp;gt; clazz=subscriber.getClass();
        Method[] methods=clazz.getMethods();
        for(Method method:methods){
            String name=method.getName();
            if(name.startsWith(&quot;onEvent&quot;)){
                Class&amp;lt;?&amp;gt; param=method.getParameterTypes()[0];
                ArrayList&amp;lt;Subscription&amp;gt; subscriptions=subscriptionsByEventType.get(param);
                if(subscriptions==null){
                    subscriptions=new ArrayList&amp;lt;&amp;gt;();
                    subscriptionsByEventType.put(param,subscriptions);
                }
                //根据函数名字决定线程
                if(name.substring(&quot;onEvent&quot;.length()).length()==0){
                    //onEvent 默认为postThread
                    subscriptions.add(new Subscription(method,subscriber, ThreadMode.PostThread));
                }else{
                    //onEventMainThread
                    subscriptions.add(new Subscription(method,subscriber, ThreadMode.MainThread));
                }
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;首先利用反射获取订阅者所在类中所有以”onEvent”开头的方法，获取方法的参数，根据参数类型去subscriptionsByEventType查找对应的ArrayList&lt;subscription&gt;,如果找不到，说明当前还没有订阅者订阅该类型的事件，就新建一个ArrayList&lt;subscription&gt;，并将该参数类型与新建的ArrayList插入到HashMap中。&lt;/subscription&gt;&lt;/subscription&gt;&lt;/p&gt;

&lt;p&gt;接下来就是构建Subscription,这里默认onEvent()为发生在PostThread,而onEventMainThread()发生在主线程main中。这样，register方法就结束，是不是很简单呢？&lt;/p&gt;

&lt;p&gt;unregister:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void unregister(Object subscriber){
        Class&amp;lt;?&amp;gt; clazz=subscriber.getClass();
        Method[] methods=clazz.getMethods();
        for(Method method:methods){
            String name=method.getName();
            if(name.startsWith(&quot;onEvent&quot;)){
                Class&amp;lt;?&amp;gt; param=method.getParameterTypes()[0];
                ArrayList&amp;lt;Subscription&amp;gt; subscriptions=subscriptionsByEventType.get(param);
                if(subscriptions!=null){
                    for(Subscription subscription:subscriptions){
                        if(subscription.subscriber==subscriber) subscriptions.remove(subscription);
                    }
                }
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;懂了register怎么写的写unregister就简单多了，同样利用反射找到onEvent*方法，获取参数类型，然后将该订阅者的所有订阅事件Sunscription从HashMap中去除即可。&lt;/p&gt;

&lt;p&gt;最后是post方法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void post(Object eventType){
        Class&amp;lt;?&amp;gt; clazz=eventType.getClass();
        ArrayList&amp;lt;Subscription&amp;gt; subscriptions=subscriptionsByEventType.get(clazz);
        if(subscriptions==null) Log.d(TAG,&quot;EventBus: no subscriber has subscribed to this event&quot;);
        else{
            for(Subscription subscription:subscriptions){
                switch (subscription.mode){
                    case MainThread:
                        mainThreadHandler.post(subscription,eventType);
                        break;
                    case PostThread:
                        try {
                            subscription.method.invoke(subscription.subscriber,eventType);
                        } catch (IllegalAccessException e) {
                            e.printStackTrace();
                        } catch (InvocationTargetException e) {
                            e.printStackTrace();
                        }
                        break;
                    default:
                        break;
                }
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;post中要做的事情是根据参数类型，从HashMap中取出所有订阅该事件的Subscription,然后依次执行每一个订阅。根据订阅事件发生的线程，这里分为两种情况。PostThread很简单，直接在post函数里执行即可，具体方法为利用Method.Invoke(Object obj,Object…args);&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;subscription.method.invoke(subscription.subscriber,eventType);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;接下来是要执行应该发生在MainThread中的订阅事件，提到主线程，我们就联想到了Handler，我们可以创建一个与主线程关联的Handler，然后将事件的处理交给Handler。&lt;/p&gt;

&lt;p&gt;MainThreadHandler:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class MainThreadHandler extends Handler {
    private Subscription subscription;
    private Object eventType;

    public MainThreadHandler(Looper looper) {
        super(looper);
    }

    @Override
    public void handleMessage(Message msg) {
        try {
            subscription.method.invoke(subscription.subscriber,eventType);
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        } catch (InvocationTargetException e) {
            e.printStackTrace();
        }
    }

    public void post(Subscription subscription,Object eventType){
        this.subscription=subscription;
        this.eventType=eventType;
        sendMessage(Message.obtain());
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后在建立EventBus的时候建立MainThreadHandler：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private EventBus(){
        mainThreadHandler=new MainThreadHandler(Looper.getMainLooper());
    };
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;至此，我们的EventBus全部完成，是不是很简单呢？接下来就是测试。&lt;/p&gt;

&lt;p&gt;我在MainActivity的界面中放了两个 Button，分别对应发生在MainThread以及子线程中。&lt;/p&gt;

&lt;p&gt;写了两个订阅函数，订阅事件类型都是ToastEvent：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class ToastEvent {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;MainActivity.java:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class MainActivity extends AppCompatActivity {
    Button bt;
    Button btAsync;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        EventBus.getDefault().register(this);
        bt= (Button) findViewById(R.id.bt);
        btAsync= (Button) findViewById(R.id.btAsync);
        bt.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                EventBus.getDefault().post(new ToastEvent());
            }
        });
        btAsync.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                new Thread(new Runnable() {
                    @Override
                    public void run() {
                        EventBus.getDefault().post(new ToastEvent());
                    }
                }).start();
            }
        });
    }

    public void onEvent(ToastEvent event){
        Log.d(&quot;YJW&quot;,&quot;onEvent: &quot;+ Thread.currentThread().getName());
    }

    public void onEventMainThread(ToastEvent event){
        Toast.makeText(this, &quot;Haha on MainThread&quot;, Toast.LENGTH_SHORT).show();
        Log.d(&quot;YJW&quot;,&quot;onEventMainThread: &quot;+ Thread.currentThread().getName());
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        EventBus.getDefault().unregister(this);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://ockr1qfi1.bkt.clouddn.com/pic1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ockr1qfi1.bkt.clouddn.com/pic2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;点击两个Button都出现Toast,并打印相应日志，上两条日志为上面的Button，下面两条日志对应下面的Button，测试功能正常。&lt;/p&gt;

&lt;p&gt;至此，大功告成。特别说明：真正的EventBus原理大致如此，不过更复杂，做了很多优化与特殊处理，还利用了注解。但作为演示，此demo足够了。&lt;/p&gt;

&lt;p&gt;#&lt;a href=&quot;https://github.com/mrrobot97/EventBus&quot;&gt;全部源代码点此&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 26 Feb 2017 00:00:00 +0800</pubDate>
        <link>http://mrrobot97.github.io/2017/02/26/%E8%87%AA%E5%B7%B1%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%89%88%E6%9C%AC%E7%9A%84EventBus.html</link>
        <guid isPermaLink="true">http://mrrobot97.github.io/2017/02/26/%E8%87%AA%E5%B7%B1%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%89%88%E6%9C%AC%E7%9A%84EventBus.html</guid>
        
        
      </item>
    
      <item>
        <title>制作一个网速显示悬浮窗</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;2016转眼就要过去了，刚刚参加完学院举办的元旦晚会，看了看系里的大牛的各种事迹，内心感慨万分。回来继续安心做我的小码农，顺便更一下将近一个月没有更新的博客。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这次带来的是一个悬浮窗网速显示计，先看下效果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ockr1qfi1.bkt.clouddn.com/demo2.gif&quot; alt=&quot;demo&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里主要是在桌面上显示一个悬浮窗，利用了WindowManager以及Service,接下来看看如何实现这样一个效果：
首先APP必须获得在桌面上显示悬浮窗的机会，很多第三方ROM都限制了这一权限，我们首先就是要申请改权限，代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public boolean checkDrawOverlayPermission() {
        if (!Settings.canDrawOverlays(this)) {
            Intent intent = new Intent(Settings.ACTION_MANAGE_OVERLAY_PERMISSION,
                    Uri.parse(&quot;package:&quot; + getPackageName()));
            startActivityForResult(intent, REQUEST_CODE);
            return false;
        }
        return true;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;该函数首先检查APP是否有显示悬浮窗的权限，如果没有，就跳转到该APP设置悬浮窗权限的界面，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ockr1qfi1.bkt.clouddn.com/662ABA6C-D700-4CEC-A883-18714BCDBCEB.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后先编写我们的悬浮窗，布局很简单，就是两个TextView：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;RelativeLayout&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;xmlns:android=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://schemas.android.com/apk/res/android&quot;&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;android:orientation=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;vertical&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;android:layout_width=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;match_parent&quot;&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;android:layout_height=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;match_parent&quot;&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;android:background=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;#88000000&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;


    &lt;span class=&quot;nt&quot;&gt;&amp;lt;TextView&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;android:layout_marginLeft=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;3dp&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;android:layout_marginRight=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;3dp&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;android:id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;@+id/speed_up&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;android:text=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;upload speed&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;android:gravity=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;left&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;android:textSize=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;10dp&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;android:layout_centerHorizontal=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;true&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;android:textColor=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;@android:color/white&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;android:layout_width=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;wrap_content&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;android:layout_height=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;wrap_content&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;nt&quot;&gt;&amp;lt;TextView&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;android:layout_marginLeft=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;3dp&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;android:layout_marginRight=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;3dp&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;android:id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;@+id/speed_down&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;android:layout_below=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;@id/speed_up&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;android:text=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;download speed&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;android:gravity=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;left&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;android:textSize=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;10dp&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;android:layout_centerHorizontal=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;true&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;android:textColor=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;@android:color/white&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;android:layout_width=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;wrap_content&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;android:layout_height=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;wrap_content&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;&amp;lt;/RelativeLayout&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;SpeedView:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class SpeedView extends FrameLayout {
    private Context mContext;
    public TextView downText;
    public TextView upText;
    private WindowManager windowManager;
    private int statusBarHeight;
    private float preX,preY,x,y;

    public SpeedView(Context context) {
        super(context);
        mContext=context;
        init();
    }

    private void init() {
        statusBarHeight=WindowUtil.statusBarHeight;
        windowManager= (WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE);
        //a view inflate itself, that&#39;s funny
        inflate(mContext,R.layout.speed_layout,this);
        downText= (TextView) findViewById(R.id.speed_down);
        upText= (TextView) findViewById(R.id.speed_up);
    }

    @Override
    public boolean onTouchEvent(MotionEvent event) {
        switch (event.getAction()){
            case MotionEvent.ACTION_DOWN:
                preX=event.getRawX();preY=event.getRawY()-statusBarHeight;
                return true;
            case MotionEvent.ACTION_MOVE:
                x=event.getRawX();y=event.getRawY()-statusBarHeight;
                WindowManager.LayoutParams params= (WindowManager.LayoutParams) getLayoutParams();
                params.x+=x-preX;
                params.y+=y-preY;
                windowManager.updateViewLayout(this,params);
                preX=x;preY=y;
                return true;
            default:
                break;

        }
        return super.onTouchEvent(event);
    }


&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;在SpeedView里我们重写了onTouchEvent事件，这样就能响应我们的拖拽事件了，注意这里更新SpeedView的位置是通过改变WindowManager.LayoutParam的x和y来实现的，调用&lt;code class=&quot;highlighter-rouge&quot;&gt;windowManager.updateViewLayout(this,params)&lt;/code&gt;来更新位置。&lt;/p&gt;

&lt;p&gt;因为我们的网速显示悬浮窗要脱离于Activity的生命周期而独立存在，因此需要通过Service来实现：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class SpeedCalculationService extends Service {
    private WindowUtil windowUtil;
    private boolean changed=false;

    @Override
    public void onCreate() {
        super.onCreate();
        WindowUtil.initX= (int) SharedPreferencesUtils.getFromSpfs(this,INIT_X,0);
        WindowUtil.initY= (int) SharedPreferencesUtils.getFromSpfs(this,INIT_Y,0);
        windowUtil=new WindowUtil(this);
    }

    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        changed=intent.getBooleanExtra(MainActivity.CHANGED,false);
        if(changed){
            windowUtil.onSettingChanged();
        }else{
            if(!windowUtil.isShowing()){
                windowUtil.showSpeedView();
            }
            SharedPreferencesUtils.putToSpfs(this,MainActivity.IS_SHOWN,true);
        }
        //return super.onStartCommand(intent, flags, startId);
        return START_STICKY;
    }



    @Nullable
    @Override
    public IBinder onBind(Intent intent) {
        return null;
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        WindowManager.LayoutParams params= (WindowManager.LayoutParams) windowUtil.speedView.getLayoutParams();
        SharedPreferencesUtils.putToSpfs(this, INIT_X,params.x);
        SharedPreferencesUtils.putToSpfs(this, INIT_Y,params.y);
        if(windowUtil.isShowing()){
            windowUtil.closeSpeedView();
            SharedPreferencesUtils.putToSpfs(this,MainActivity.IS_SHOWN,false);
        }
        Log.d(&quot;yjw&quot;,&quot;service destroy&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里的WindowUtil其实就是一个工具类，帮助我们控制悬浮窗SpeedView的显示与隐藏：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class WindowUtil {
    public static int statusBarHeight=0;
    //记录悬浮窗的位置
    public static int initX,initY;
    private WindowManager windowManager;
    public SpeedView speedView;
    private WindowManager.LayoutParams params;
    private Context context;

    public boolean isShowing() {
        return isShowing;
    }

    private boolean isShowing=false;

    public static final int INTERVAL=2000;
    private long preRxBytes,preSeBytes;
    private long rxBytes,seBytes;
    private Handler handler=new Handler(){
        @Override
        public void dispatchMessage(Message msg) {
            super.dispatchMessage(msg);
            calculateNetSpeed();
            sendEmptyMessageDelayed(0,INTERVAL);
        }
    };

    public void onSettingChanged(){
        String setting= (String) SharedPreferencesUtils.getFromSpfs(context,MainActivity.SETTING,MainActivity.BOTH);
        if(setting.equals(MainActivity.BOTH)){
            speedView.upText.setVisibility(View.VISIBLE);
            speedView.downText.setVisibility(View.VISIBLE);
        }else if(setting.equals(MainActivity.UP)){
            speedView.upText.setVisibility(View.VISIBLE);
            speedView.downText.setVisibility(View.GONE);
        }else{
            speedView.upText.setVisibility(View.GONE);
            speedView.downText.setVisibility(View.VISIBLE);
        }
    }

    private void calculateNetSpeed() {
        rxBytes=TrafficStats.getTotalRxBytes();
        seBytes=TrafficStats.getTotalTxBytes()-rxBytes;
        double downloadSpeed=(rxBytes-preRxBytes)/2;
        double uploadSpeed=(seBytes-preSeBytes)/2;
        preRxBytes=rxBytes;
        preSeBytes=seBytes;
        //根据范围决定显示单位
        String upSpeed=null;
        String downSpeed=null;

        NumberFormat df= java.text.NumberFormat.getNumberInstance();
        df.setMaximumFractionDigits(2);

        if(downloadSpeed&amp;gt;1024*1024){
            downloadSpeed/=(1024*1024);
            downSpeed=df.format(downloadSpeed)+&quot;MB/s&quot;;
        }else if(downloadSpeed&amp;gt;1024){
            downloadSpeed/=(1024);
            downSpeed=df.format(downloadSpeed)+&quot;B/s&quot;;
        }else{
            downSpeed=df.format(downloadSpeed)+&quot;B/s&quot;;
        }

        if(uploadSpeed&amp;gt;1024*1024){
            uploadSpeed/=(1024*1024);
            upSpeed=df.format(uploadSpeed)+&quot;MB/s&quot;;
        }else if(uploadSpeed&amp;gt;1024){
            uploadSpeed/=(1024);
            upSpeed=df.format(uploadSpeed)+&quot;kB/s&quot;;
        }else{
            upSpeed=df.format(uploadSpeed)+&quot;B/s&quot;;
        }

        updateSpeed(&quot;↓ &quot;+downSpeed,&quot;↑ &quot;+upSpeed);
    }

    public WindowUtil(Context context) {
        this.context = context;
        windowManager= (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
        speedView=new SpeedView(context);
        params=new WindowManager.LayoutParams();
        params=new WindowManager.LayoutParams();
        params.x=initX;
        params.y=initY;
        params.width=params.height=WindowManager.LayoutParams.WRAP_CONTENT;
        params.type=WindowManager.LayoutParams.TYPE_PHONE;
        params.gravity= Gravity.LEFT|Gravity.TOP;
        params.format= PixelFormat.RGBA_8888;
        params.flags=WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE| WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL;
                //设置悬浮窗可以拖拽至状态栏的位置
//        | WindowManager.LayoutParams.FLAG_FULLSCREEN| WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN;

    }

    public void showSpeedView(){
        windowManager.addView(speedView,params);
        isShowing=true;
        preRxBytes= TrafficStats.getTotalRxBytes();
        preSeBytes=TrafficStats.getTotalTxBytes()-preRxBytes;
        handler.sendEmptyMessage(0);
    }

    public void closeSpeedView(){
        windowManager.removeView(speedView);
        isShowing=false;
    }

    public void updateSpeed(String downSpeed,String upSpeed){
        speedView.upText.setText(upSpeed);
        speedView.downText.setText(downSpeed);
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;WindowUtil类中也包含了一个很重要的方法，那就是计算网速。这里计算网速的方法很简单，Android提供了一个类&lt;code class=&quot;highlighter-rouge&quot;&gt;TrafficStats&lt;/code&gt;,这个类里面为我们提供了好多接口，我们用到了其中的两个:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.public static long getTotalTxBytes ()
Return number of bytes transmitted since device boot. Counts packets across all network interfaces, and always increases monotonically since device boot. Statistics are measured at the network layer, so they include both TCP and UDP usage.
2.public static long getTotalRxPackets ()
Return number of packets received since device boot. Counts packets across all network interfaces, and always increases monotonically since device boot. Statistics are measured at the network layer, so they include both TCP and UDP usage.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以看出，getTotalTxBytes()方法返回系统自开机到现在为止所一共传输的数据的字节数，包括上传的数据和下载的数据；而getTotalRxPackets()方法返回的是系统自开机到现在为止所一共接收到也就是下载的数据的字节数，用getTotalTxBytes()-getTotalRxPackets()自然就是系统开机到现在为止所上传的数据的字节数。&lt;/p&gt;

&lt;p&gt;这样每隔一定时间，我们计算一下系统自开机到目前所接受的数据包的字节数和所发送的数据的字节数的变化量，用变化量除以时间，就是这段时间的平均网速了。&lt;/p&gt;

&lt;p&gt;为了每个一段时间计算一下网速，我们利用了一个Handler来实现这个定时任务&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private Handler handler=new Handler(){
        @Override
        public void dispatchMessage(Message msg) {
            super.dispatchMessage(msg);
            calculateNetSpeed();
            sendEmptyMessageDelayed(0,INTERVAL);
        }
    };
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里要注意将SpeedView添加到屏幕上，也就是添加到WindowManager里的时候，这个WindowManager.LayoutParams十分重要，其参数都是有用的，这里就不细讲了,详细介绍请移步&lt;a href=&quot;https://developer.android.com/reference/android/view/WindowManager.LayoutParams.html&quot;&gt;官方文档&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;最后要将我们的悬浮窗设置为开机自启动的，利用一个BroadcastReceiver就可以了：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class MyBroadcastReceiver extends BroadcastReceiver {
    @Override
    public void onReceive(Context context, Intent intent) {
        Log.d(&quot;yjw&quot;,&quot;receiver receive boot broadcast&quot;);
        boolean isShown= (boolean) SharedPreferencesUtils.getFromSpfs(context,MainActivity.IS_SHOWN,false);
        if(isShown){
            context.startService(new Intent(context,SpeedCalculationService.class));
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;在Manifest里这样注册我们的BroadcastReceiver：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &amp;lt;receiver android:name=&quot;me.mrrobot97.netspeed.MyBroadcastReceiver&quot;&amp;gt;
            &amp;lt;intent-filter&amp;gt;
                &amp;lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot; /&amp;gt;
                &amp;lt;category android:name=&quot;android.intent.category.HOME&quot; /&amp;gt;
            &amp;lt;/intent-filter&amp;gt;
        &amp;lt;/receiver&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样当系统启动完成，就会开启我们的Service。注意这里&lt;intent-filter&gt;中的&lt;category&gt;不可省略，亲测省略后BroadcastReceiver无法接收到系统广播。&lt;/category&gt;&lt;/intent-filter&gt;&lt;/p&gt;

&lt;p&gt;最后还有一点，在Manifest的MainActivity条目中加一个属性：&lt;code class=&quot;highlighter-rouge&quot;&gt;android:excludeFromRecents=&quot;true&quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这样我们的ManiActivity就不会显示在最近任务列表，防止用户清空任务列表时将我们的Sercvice进程终结了。&lt;/p&gt;

&lt;p&gt;完整的项目地址&lt;a href=&quot;https://github.com/mrrobot97/NetSpeed&quot;&gt;Github&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Fri, 30 Dec 2016 00:00:00 +0800</pubDate>
        <link>http://mrrobot97.github.io/2016/12/30/%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AA%E7%BD%91%E9%80%9F%E6%98%BE%E7%A4%BA%E6%82%AC%E6%B5%AE%E7%AA%97.html</link>
        <guid isPermaLink="true">http://mrrobot97.github.io/2016/12/30/%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AA%E7%BD%91%E9%80%9F%E6%98%BE%E7%A4%BA%E6%82%AC%E6%B5%AE%E7%AA%97.html</guid>
        
        
      </item>
    
      <item>
        <title>Dribbble第三方开源客户端Designer</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;Dribbble是一个优秀的设计师网站，这里有上万优秀设计师为移动开发人员提供了海量精美的UI资源。Dribbble很早就开放了API，也有许多优秀的第三方客户端，本着学习的目的，我在课余时间写了这个还很粗糙的客户端。目前的功能还很简陋，用户体验也不是很完善，主要是因为Dribbble的API服务器在国外，国内加载资源很慢。不过，我会慢慢更新的，一点一点把它变得更好。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/mrrobot97/Designer&quot;&gt;项目github地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;先看一下预览图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ockr1qfi1.bkt.clouddn.com/screener_20161029%2800_13_49%29.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ockr1qfi1.bkt.clouddn.com/screener_20161028%2823_54_36%29.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ockr1qfi1.bkt.clouddn.com/screener_20161029%2800_14_23%29.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ockr1qfi1.bkt.clouddn.com/screener_20161029%2800_15_02%29.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ockr1qfi1.bkt.clouddn.com/screener_20161029%2800_15_24%29.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ockr1qfi1.bkt.clouddn.com/screener_20161029%2800_15_39%29.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;主要使用的技术和开源项目:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.	MVP设计模式。
2.	RxJAVA
3.	Retrofit
4.	OkHttp
5.	Glide
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;feature:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.支持页面滑动返回
2.支持离线缓存浏览
3.支持JAVA 8
4.支持Oauth2.0认证登录
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;todo list：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;del&gt;使用数据库离线缓存,节省客户端流量。&lt;/del&gt; (已使用OKHttp离线缓存代替)
    &lt;ol&gt;
      &lt;li&gt;使用palette动态改变背景色，增加美观性。&lt;/li&gt;
      &lt;li&gt;使用Dribbble提供的Oauth2认证允许用户登录，并对每个设计进行评论，点赞，收藏等功能。(已初步实现Oauth2.0认证登陆)&lt;/li&gt;
      &lt;li&gt;改善图片加载速度，提供友好的用户反馈。&lt;/li&gt;
      &lt;li&gt;发现并消灭BUG，提高软件使用的稳定性。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;欢迎fork、issue、star。&lt;/p&gt;

&lt;h1 id=&quot;changelog&quot;&gt;ChangeLog&lt;/h1&gt;

&lt;h2 id=&quot;version-011&quot;&gt;version 0.1.1&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.加入Oauth2.0登录入口，用户可以登录并查看自己的个人信息。
2.利用OKHttp加入离线缓存，没有网也可以愉快的玩耍了。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;version-011-apk-downloadhttpockr1qfi1bktclouddncomrelease011apk&quot;&gt;&lt;a href=&quot;http://ockr1qfi1.bkt.clouddn.com/release0.1.1.apk&quot;&gt;version 0.1.1 apk download&lt;/a&gt;&lt;/h2&gt;

&lt;h2 id=&quot;version-010-apk-downloadhttpockr1qfi1bktclouddncomdesignerapk&quot;&gt;&lt;a href=&quot;http://ockr1qfi1.bkt.clouddn.com/Designer.apk&quot;&gt;version 0.1.0 apk download&lt;/a&gt;&lt;/h2&gt;
</description>
        <pubDate>Sat, 05 Nov 2016 00:00:00 +0800</pubDate>
        <link>http://mrrobot97.github.io/2016/11/05/Dribbble%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BC%80%E6%BA%90%E5%AE%A2%E6%88%B7%E7%AB%AFDesigner.html</link>
        <guid isPermaLink="true">http://mrrobot97.github.io/2016/11/05/Dribbble%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BC%80%E6%BA%90%E5%AE%A2%E6%88%B7%E7%AB%AFDesigner.html</guid>
        
        
      </item>
    
      <item>
        <title>使用MonkeyRunner进行Android应用自动化测试</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;MonkeyRunner是谷歌官方SDK tools 中为我们提供的一个程序自动化测试工具，需要开发者编写相应的python自动测试脚本，开发者可以自定义测试流程，功能很全面，可以模拟各种事件。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;monkeyrunner位于SDK/tools/monkeyrunner,这是一个可执行脚本，我们编写自己的测试脚本然后用monkeyrunner运行即可。&lt;/p&gt;

&lt;p&gt;谷歌提供了一个python库com.android.monkeyrunner，便于我们编写测试脚本。看一个脚本demo:
monkeyrunner.py&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from com.android.monkeyrunner import MonkeyRunner, MonkeyDevice, MonkeyImage


device = MonkeyRunner.waitForConnection()

package = &#39;me.mrrobot97.swipeback&#39;

activity = &#39;me.mrrobot97.swipeback.MainActivity&#39;

runComponent = package + &#39;/&#39; + activity

device.startActivity(component=runComponent)

MonkeyRunner.sleep(1)

for i in range(0, 5):
	device.touch(720, 1280, &#39;DOWN_AND_UP&#39;)
	MonkeyRunner.sleep(0.5)

for i in range(0, 5):
	device.drag((1, 1280), (720, 1280), 0.5, 50)
	MonkeyRunner.sleep(0.7)

img=device.takeSnapshot()

img.writeToFile(&#39;screen.png&#39;,&#39;png&#39;)

print &#39;finished&#39;


&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;三个module分别为MonkeyRunner,MonkeyDevice,MonkeyImage，每一个都包含了许多与APP交互的API，可以在网上查到相应的文档。&lt;/p&gt;

&lt;p&gt;终端运行:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; monkeyrunner monkeyrunner.py 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;即可在虚拟机或真机中观察到效果:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ockr1qfi1.bkt.clouddn.com/auto-test.gif&quot; alt=&quot;Demo&quot; /&gt;&lt;/p&gt;

&lt;p&gt;关于MonkeyRunner具体的用法请上网查API文档。&lt;/p&gt;
</description>
        <pubDate>Sun, 16 Oct 2016 00:00:00 +0800</pubDate>
        <link>http://mrrobot97.github.io/2016/10/16/%E4%BD%BF%E7%94%A8MonkeyRunner%E8%BF%9B%E8%A1%8CAndroid%E5%BA%94%E7%94%A8%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95.html</link>
        <guid isPermaLink="true">http://mrrobot97.github.io/2016/10/16/%E4%BD%BF%E7%94%A8MonkeyRunner%E8%BF%9B%E8%A1%8CAndroid%E5%BA%94%E7%94%A8%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95.html</guid>
        
        
      </item>
    
      <item>
        <title>动手写一个高仿微信的滑动返回SwipeBackActivity</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;本文来源于&lt;a href=&quot;https://github.com/XBeats/and_swipeback&quot;&gt;这个开源项目&lt;/a&gt;，由于作者只给出了用法和基本原理，因此才有了本文的产生。本文去除了原项目中较琐碎和不必要的一些内容，只实现了基本的Activity滑动返回功能。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;先看效果图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ockr1qfi1.bkt.clouddn.com/swipebackdemo.gif&quot; alt=&quot;demo&quot; /&gt;&lt;/p&gt;

&lt;p&gt;效果还是挺不错的。&lt;/p&gt;

&lt;p&gt;基本原理：利用Application类的registerActivityLifecycleCallbacks(ActivityLifecycleCallbacks)方法，可以记录全局所有Activity的生命周期，因此我们可以利用这点来存储我们所有的Activity于一个栈中，每次滑动返回时从栈中取出前一个Activtity,然后分离出其中id为&lt;code class=&quot;highlighter-rouge&quot;&gt;Window.ID_ANDROID_CONTENT&lt;/code&gt;的FrameLayout，这个FrameLayout就是我们setContentView中的那个view的父view,利用这个FrameLayout就可以获取Activity界面显示的View。然后我们监听手势事件，在滑动的时候将前一个Activity的View加载进来并不断更改其偏移量即可。&lt;/p&gt;

&lt;p&gt;首先是实现ActivityLifecycleCallbacks接口，并在其中用一个栈存储我们所有的Activity:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class ActivityLifeCycleHelper implements Application.ActivityLifecycleCallbacks {
    private Stack&amp;lt;Activity&amp;gt; mActivities;

    public ActivityLifeCycleHelper(){
        mActivities=new Stack&amp;lt;&amp;gt;();
    }

    @Override
    public void onActivityCreated(Activity activity, Bundle bundle) {
        mActivities.add(activity);
    }

    @Override
    public void onActivityStarted(Activity activity) {

    }

    @Override
    public void onActivityResumed(Activity activity) {

    }

    @Override
    public void onActivityPaused(Activity activity) {

    }

    @Override
    public void onActivityStopped(Activity activity) {

    }

    @Override
    public void onActivitySaveInstanceState(Activity activity, Bundle bundle) {

    }

    @Override
    public void onActivityDestroyed(Activity activity) {
        mActivities.remove(activity);
    }

    public Activity getPreActivity(){
        int size=mActivities.size();
        if(size&amp;lt;2) return null;
        else return mActivities.get(size-2);
    }

    public void removeActivity(Activity activity){
        mActivities.remove(activity);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;看得出这个类很简单，只是在Activity创建的时候加入栈中，销毁的时候移除。
然后就是在Application中调用registerActivityLifecycleCallbacks()方法了:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class MyApplication extends Application {
    public ActivityLifeCycleHelper getHelper() {
        return mHelper;
    }

    private ActivityLifeCycleHelper mHelper;
    @Override
    public void onCreate() {
        super.onCreate();
        mHelper=new ActivityLifeCycleHelper();
        //store all the activities
        registerActivityLifecycleCallbacks(mHelper);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后定义一个最基本的SwipeBackActivity,当然要继承自AppCompactActivity，这个类我们要做的就是重写它的dispatchTouchEvent()方法，这是因为我们要监听边界滑动返回事件，肯定要拦截其中的一些触摸事件。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class SwipeBackActivity extends AppCompatActivity {
    private TouchHelepr mTouchHelepr;

    @Override
    public boolean dispatchTouchEvent(MotionEvent ev) {
        if(mTouchHelepr==null)
            mTouchHelepr=new TouchHelepr(getWindow());
        return super.dispatchTouchEvent(ev)&amp;amp;&amp;amp;mTouchHelepr.processTouchEvent(ev);
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这里有一个我们自己写的类TouchHelper，具体的逻辑操作就在这里面实现了。接下来就是重点类TouchHelper了。
首先我们定义三个状态:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	private boolean isIdle=true;
    private boolean isSlinding=false;
    private boolean isAnimating=false;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;isIdle,表示当前为静止状态。&lt;/li&gt;
  &lt;li&gt;isSliding,表示当前用户手指移动，我们的View随之滑动。&lt;/li&gt;
  &lt;li&gt;isAnimating，表示用户手指松开，View要么恢复原状，要么移动至最右并消失，这是一个Animation过程，isAnimating=true表示当前处于这种动画过程中。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;然后是几个成员变量:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	private Window mWindow;
    private ViewGroup preContentView;
    private ViewGroup curContentView;
    private ViewGroup curView;
    private ViewGroup preView;
    private Activity preActivity; 
    
    //左边触发的宽度
    private int triggerWidth=50;
	//阴影宽度
    private int SHADOW_WIDTH=30;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;mWindow用于初始化TouchHelper，并且这个window就包含了context,activity等信息。&lt;/p&gt;

&lt;p&gt;curContentView、preContentView分别表示当前、前一个Activity中外层的FrameLayout。&lt;/p&gt;

&lt;p&gt;curView、preView分别表示当前、前一个Activity的界面View。&lt;/p&gt;

&lt;p&gt;然后就是处理手势的代码了：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private Context getContext(){
        return mWindow.getContext();
    }

//决定是否拦截事件
    public boolean processTouchEvent(MotionEvent event){
        if(isAnimating) return true;
        float x=event.getRawX();
        switch (event.getAction()){
            case MotionEvent.ACTION_DOWN:
                if(x&amp;lt;=triggerWidth){
                    isIdle=false;
                    isSlinding=true;
                    startSlide();
                    return true;
                }
                break;
            case MotionEvent.ACTION_POINTER_DOWN:
                if(isSlinding) return true;
                break;
            case MotionEvent.ACTION_MOVE:
                if(isSlinding){
                    if(event.getActionIndex()!=0) return true;
                    sliding(x);
                }
                break;
            case MotionEvent.ACTION_CANCEL:
            case MotionEvent.ACTION_UP:
                if(!isSlinding) return false;
                int width=getContext().getResources().getDisplayMetrics().widthPixels;
                isAnimating=true;
                isSlinding=false;
                startAnimating(width/x&amp;lt;=3,x);
                return true;
            default:
                break;
        }
        return false;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;在函数processTouchEvent()中所有要拦截的地方我们都return true,这样子View就不会受到触摸事件了，其余的则应返回false,表示将触摸事件分发给子View去处理。&lt;/p&gt;

&lt;p&gt;其中状态更改的代码比较简单，就不解释了。主要说说其中随着状态更改而进行的几个操作函数:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;startSlide()&lt;/li&gt;
  &lt;li&gt;sliding(x)&lt;/li&gt;
  &lt;li&gt;startAnimating(width/x&amp;lt;=3,x)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;startSlide(),顾名思义，开始滑动，先看看代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private void startSlide() {
        preActivity=((MyApplication)getContext().getApplicationContext()).getHelper().getPreActivity();
        if(preActivity==null) return;
        preContentView=(ViewGroup) preActivity.getWindow().findViewById(Window.ID_ANDROID_CONTENT);
        preView= (ViewGroup) preContentView.getChildAt(0);
        preContentView.removeView(preView);
        curContentView=(ViewGroup) mWindow.findViewById(Window.ID_ANDROID_CONTENT);
        curView= (ViewGroup) curContentView.getChildAt(0);
        preView.setX(-preView.getWidth()/3);
        curContentView.addView(preView,0);
        //        if(mShadowView==null){
//            mShadowView=new ShadowView(getContext());
//        }
//        FrameLayout.LayoutParams params=new FrameLayout.LayoutParams(SHADOW_WIDTH, FrameLayout.LayoutParams.MATCH_PARENT);
//        curContentView.addView(mShadowView,1,params);
//        mShadowView.setX(-SHADOW_WIDTH);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在startSlide()中，我们给几个成员变量赋值，并且将preView添加到curContentView中，并赋予其一个初始偏移量。这里要特别注意addView(view,index)中的index参数，index参数越大，代表越靠后绘制。这里添加preView时的index为0，表示最先绘制preView，否则preView会显示在curView的上面，这样就不正确了。注释部分稍后再讲。&lt;/p&gt;

&lt;p&gt;然后看看sliding()方法:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private void sliding(float rawX) {
        if(preActivity==null) return;
        curView.setX(rawX);
        preView.setX(-preView.getWidth()/3+rawX/3);
        //mShadowView.setX(-SHADOW_WIDTH+rawX);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这个函数就简单多了，这是随着用户手指的位置动态地更改curView、preView而已。注释稍后讲。&lt;/p&gt;

&lt;p&gt;然后是startAnimating()方法:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private void startAnimating(final boolean isFinishing, float x) {
        int width=getContext().getResources().getDisplayMetrics().widthPixels;
        ValueAnimator animator=ValueAnimator.ofFloat(x,isFinishing?width:0);
        animator.setInterpolator(new DecelerateInterpolator());
        animator.setDuration(200);
        animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
            @Override
            public void onAnimationUpdate(ValueAnimator valueAnimator) {
                sliding((Float) valueAnimator.getAnimatedValue());
            }
        });
        animator.addListener(new Animator.AnimatorListener() {
            @Override
            public void onAnimationStart(Animator animator) {

            }

            @Override
            public void onAnimationEnd(Animator animator) {
                doEndWorks(isFinishing);
            }

            @Override
            public void onAnimationCancel(Animator animator) {

            }

            @Override
            public void onAnimationRepeat(Animator animator) {

            }
        });
        animator.start();
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当用户松开手指时的位置的x坐标小于屏幕宽度的1/3时，恢复原状，否则将preView完全显示，这里利用ValueAnimator来实现动画。注意在动画完成后我们还要做一些收尾工作，就是方法doEndWorks():&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private void doEndWorks(boolean isFinishing) {
        if(preActivity==null) return;
        if(isFinishing){
            //更改当前activity的底view为preView,防止当前activity finish时的白屏闪烁
            BackView view=new BackView(getContext());
            view.cacheView(preView);
            curContentView.addView(view,0);
        }
        //curContentView.removeView(mShadowView);
        if(curContentView==null||preContentView==null) return;
        curContentView.removeView(preView);
        preContentView.addView(preView);
        if(isFinishing){
            ((Activity)getContext()).finish();
            ((Activity)getContext()).overridePendingTransition(0,0);
        }
        isAnimating=false;
        isSlinding=false;
        isIdle=true;
        preView=null;
        curView=null;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;收尾工作中我们将状态修正，该移除的View移除，该添加的View添加。若preView完全显示，就finish当前activity,注意还要利用&lt;code class=&quot;highlighter-rouge&quot;&gt;((Activity)getContext()).overridePendingTransition(0,0)&lt;/code&gt;取消默认的activity更换动画，这样才能实现暗度陈仓的目的。你应该已经看到了这里还有一个BackView，这个BackView其实就是preView的一个副本，我们将BackView添加到curContentView的最底部，覆盖那个白色底部，否则动画完成后会有一个白屏闪烁现象。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//用于防止白屏闪烁
class BackView extends View{

    private View mView;
    public BackView(Context context) {
        super(context);
    }

    public void cacheView(View view){
        mView=view;
        invalidate();
    }

    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);
        if(mView!=null){
            mView.draw(canvas);
            mView=null;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样实现的效果就是如下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ockr1qfi1.bkt.clouddn.com/withouwshadowview.gif&quot; alt=&quot;demo&quot; /&gt;&lt;/p&gt;

&lt;p&gt;你应该注意要这个和第一个demo显示的不太一样，因为这里没有阴影效果，体现不出层次感，不够美观，那么接下来我们只需要在添加一点点代码就可以添加这样的一个阴影效果.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class ShadowView extends View{

    private Drawable mDrawable;

    public ShadowView(Context context) {
        super(context);
        int[] colors=new int[]{0x00000000, 0x17000000, 0x43000000};
        mDrawable=new GradientDrawable(GradientDrawable.Orientation.LEFT_RIGHT,colors);
    }

    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);
        mDrawable.setBounds(0,0,getMeasuredWidth(),getMeasuredHeight());
        mDrawable.draw(canvas);
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这个就是要绘制上去的阴影效果，很简单，将前面几个方法中注释的代码部分还原即可。&lt;/p&gt;

&lt;p&gt;这样，就完成了我们所有的代码~~~&lt;/p&gt;

&lt;p&gt;喜欢的话，去给&lt;a href=&quot;https://github.com/XBeats/and_swipeback&quot;&gt;原项目&lt;/a&gt;start吧，当然如果你能给我的文章一个喜欢话我会更开心的~&lt;/p&gt;
</description>
        <pubDate>Sat, 15 Oct 2016 00:00:00 +0800</pubDate>
        <link>http://mrrobot97.github.io/2016/10/15/%E5%8A%A8%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E9%AB%98%E4%BB%BF%E5%BE%AE%E4%BF%A1%E7%9A%84%E6%BB%91%E5%8A%A8%E8%BF%94%E5%9B%9ESwipeBackActivity.html</link>
        <guid isPermaLink="true">http://mrrobot97.github.io/2016/10/15/%E5%8A%A8%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E9%AB%98%E4%BB%BF%E5%BE%AE%E4%BF%A1%E7%9A%84%E6%BB%91%E5%8A%A8%E8%BF%94%E5%9B%9ESwipeBackActivity.html</guid>
        
        
      </item>
    
      <item>
        <title>使用Android Studio 进行NDK开发基础</title>
        <description>&lt;h2 id=&quot;ndk&quot;&gt;配置NDK环境&lt;/h2&gt;
&lt;p&gt;在SDKManager中下载NDK依赖包以及额外工具，只需要勾选NDK、LLDB、CMAKE：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://developer.android.com/studio/images/projects/ndk-install_2-2_2x.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;安装完成后，重启AndroidStudio即可自动配置好NDK开发环境。&lt;/p&gt;

&lt;h2 id=&quot;jni&quot;&gt;JNI调用&lt;/h2&gt;

&lt;h3 id=&quot;native&quot;&gt;定义本地Native方法&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class HelloJNI {
    
    public native String getStringFromC();
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;此时getStringFromC()方法会报错，这是由于找不到这个方法，无视之，直接build project。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;生成头文件&lt;/h3&gt;

&lt;p&gt;build成功后进入app/build/intermediates/classes/debug目录下，使用命令行javah生成HelloJNI中的native方法对应的头文件：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javah -jni me.mrrobot97.hellojni.HelloJNI
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;注意包名以及类名都要正确，成功运行后在debug目录下就会生成一个头文件&lt;code class=&quot;highlighter-rouge&quot;&gt;me_mrrobot97_hellojni_HelloJNI.h&lt;/code&gt;，我们将这个头文件拷贝至AndroidStudio的JNI目录下，没有这个目录就手动创建一个，然后根据这个头文件创建对应的C文件，同样放置于JNI目录下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &quot;me_mrrobot97_hellojni_HelloJNI.h&quot;

JNIEXPORT jstring JNICALL Java_me_mrrobot97_hellojni_HelloJNI_getStringFromC
  (JNIEnv * env, jobject obj)
  {
        return (*env)-&amp;gt;NewStringUTF(env, &quot;Hello JNI!&quot;);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;gradle&quot;&gt;修改gradle&lt;/h3&gt;
&lt;p&gt;然后修改module级别的build.gradle文件，在defaultConfig中加入如下配置：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ndk{
            moduleName &quot;hellojni&quot;
   }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这里的moduleName就是我们要生成的.so文件的名字。修改gradle.properties,加入如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;android.useDeprecatedNdk=true
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后就可以build了，build后会在app/build/intermediates/ndk/目录下生成对应的.so文件。有了.so文件我们就不需要JNI目录下的C文件了，直接在HelloJNI类中加入:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static {
        System.loadLibrary(&quot;hellojni&quot;);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;就可以使用我们定义的native方法了。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        HelloJNI helloJNI=new HelloJNI();
        Log.d(&quot;yjw&quot;,helloJNI.getStringFromC());
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;运行项目，查看log:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;10-10 05:53:43.958 1811-1811/? D/yjw: Hello JNI!
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;证实我们已经成功调用了.so文件来实现native方法调用了！&lt;/p&gt;

&lt;p&gt;上面的方法是针对只有源C文件而无.so文件的使用步骤，如果我们有现成的.so文件，直接调用System.loadLibrary即可。&lt;/p&gt;
</description>
        <pubDate>Mon, 10 Oct 2016 00:00:00 +0800</pubDate>
        <link>http://mrrobot97.github.io/2016/10/10/%E4%BD%BF%E7%94%A8Android-Studio-%E8%BF%9B%E8%A1%8CNDK%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80.html</link>
        <guid isPermaLink="true">http://mrrobot97.github.io/2016/10/10/%E4%BD%BF%E7%94%A8Android-Studio-%E8%BF%9B%E8%A1%8CNDK%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80.html</guid>
        
        
      </item>
    
      <item>
        <title>使用ItemTouchHelper实现RecyclerView的拖动排序、滑动删除</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;Google为我们提供的RecyclerView真的是非常的好用，高度可定制化，这次我们利用ItemTouchHelper来实现对RecyclerView的拖动排序以及滑动删除。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;先看看效果图:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ockr1qfi1.bkt.clouddn.com/demo.gif&quot; alt=&quot;效果图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;效果还是不错的，如果再结合自定义的ItemAnimator,可以实现很漂亮的花样。&lt;/p&gt;

&lt;p&gt;首先我们要定义一个类实现&lt;code class=&quot;highlighter-rouge&quot;&gt;ItemTouchHelper.Callback&lt;/code&gt;接口，然后实现其中的几个方法:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.public boolean isLongPressDragEnabled()
2.public boolean isItemViewSwipeEnabled()
3.public int getMovementFlags(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder)
4.public boolean onMove(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, RecyclerView.ViewHolder target)
5.public void onSwiped(RecyclerView.ViewHolder viewHolder, int direction)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中isLongPressDragEnable是决定是否可以通过长按Item来对其排序，isItemViewSwipeEnable决定是否可以滑动Item，只需要在需要实现的功能里面返回true即可，这里我们两个都返回true&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Override
    public boolean isLongPressDragEnabled() {
        return true;
    }

    @Override
    public boolean isItemViewSwipeEnabled() {
        return true;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后就是重写onMove和onSwiped方法了，在这两个方法里面我们可以获取需要改变的item的位置，然后我们需要将这些位置通知给我们的Adapter，做法是定义一个接口：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public interface OnDragListener {

    void onDrag(int from,int to);

    void onDismiss(int pos);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;让MainActivity实现这个接口，然后重写这两个方法，并通知Adapter数据更新:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Override
    public void onDrag(int from, int to) {
        Collections.swap(mList,from,to);
        mAdapter.notifyItemMoved(from,to);
    }

    @Override
    public void onDismiss(int pos) {
        mList.remove(pos);
        mAdapter.notifyItemRemoved(pos);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;onMove以及onSwiped方法如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Override
    public int getMovementFlags(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder) {
        int dragFlags=ItemTouchHelper.DOWN|ItemTouchHelper.UP|ItemTouchHelper.LEFT|ItemTouchHelper.RIGHT;
        int swipeFlags=ItemTouchHelper.LEFT|ItemTouchHelper.RIGHT;

        return makeMovementFlags(dragFlags,swipeFlags);
    }

    @Override
    public boolean onMove(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, RecyclerView.ViewHolder target) {
        mListener.onDrag(viewHolder.getAdapterPosition(),target.getAdapterPosition());
        return true;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;makeMovementFlags()是用来控制滑动以及拖动的方向的，用法如上所示。&lt;/p&gt;

&lt;p&gt;最后就是在MainActivity中将我们的ItemTouchHelper.Callback与RecyclerView绑定:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ItemTouchHelper.Callback callback=new MyItemTouchHelper(this);
        ItemTouchHelper helper=new ItemTouchHelper(callback);
        helper.attachToRecyclerView(mRecyclerView);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样所有的工作就做完了。
完整的项目源码地址&lt;a href=&quot;https://github.com/mrrobot97/DragableRecyclerView&quot;&gt;在此&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 27 Sep 2016 00:00:00 +0800</pubDate>
        <link>http://mrrobot97.github.io/2016/09/27/%E4%BD%BF%E7%94%A8ItemTouchHelper%E5%AE%9E%E7%8E%B0RecyclerView%E7%9A%84%E6%8B%96%E5%8A%A8%E6%8E%92%E5%BA%8F-%E6%BB%91%E5%8A%A8%E5%88%A0%E9%99%A4.html</link>
        <guid isPermaLink="true">http://mrrobot97.github.io/2016/09/27/%E4%BD%BF%E7%94%A8ItemTouchHelper%E5%AE%9E%E7%8E%B0RecyclerView%E7%9A%84%E6%8B%96%E5%8A%A8%E6%8E%92%E5%BA%8F-%E6%BB%91%E5%8A%A8%E5%88%A0%E9%99%A4.html</guid>
        
        
      </item>
    
      <item>
        <title>利用二阶贝塞尔曲线绘制动态波浪</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;利用贝塞尔曲线我们可以很好地拟合出各种曲线效果，其中二阶贝塞尔曲线可以用来模拟正弦曲线，及我们的“波浪”效果。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;先上效果图:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ockr1qfi1.bkt.clouddn.com/ezgif.com-video-to-gif.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们自定义一个WaveView，在onDraw中绘制我们的波浪，当然我们只能绘制静态的曲线，但是我们可以在onDraw中不断的调用invalidate()来实现模拟一帧帧的动画效果。&lt;/p&gt;

&lt;p&gt;Android中的贝塞尔曲线是利用Path.quadTo(x1,y1,x2,y2)来实现二阶贝塞尔曲线的，其中x1,y1和x2,y2即分别为二阶贝塞尔曲线中的P1和P2，Path的起点即为P0.&lt;/p&gt;

&lt;p&gt;width和height为我们定义的浪宽和浪高，sWidth和sHeight为屏幕的宽和高，我们在每一次onDraw中绘制出多条波浪，然后调用invalidate，并且平移一点x，即可实现动画效果:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class WaveView extends View {
    private Paint mPaint;
    //single wave height and weidth
    private int width,height;
    //screen width,height
    private int sWidth,sHeight;
    private int waveColor= Color.BLUE;
    private Path mPath;
    private int strokeWidth;
    private float x,y;

    private boolean isAnim=false;

    public WaveView(Context context) {
        this(context,null);
    }

    public WaveView(Context context, AttributeSet attrs) {
        this(context, attrs,0);
    }

    public WaveView(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
        init();
    }

    private void init() {
        strokeWidth=ScreenUtils.dp2px(getContext(),4);
        mPaint=new Paint();
        mPaint.setAntiAlias(true);
        mPaint.setColor(waveColor);
        mPaint.setStyle(Paint.Style.STROKE);
        mPaint.setStrokeWidth(strokeWidth);
        width=ScreenUtils.dp2px(getContext(),50);
        height=ScreenUtils.dp2px(getContext(),40);
        int[] wh=ScreenUtils.getScreenWidthAndHeight(getContext());
        sWidth=wh[0];
        sHeight=wh[1]-ScreenUtils.getStatusBarHeight(getContext());
        mPath=new Path();
        x=0;
        y=sHeight/2;
    }

    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);
        mPath.reset();
        mPath.moveTo(x,y);
        float tmpX=x;
        for(int i=0;tmpX&amp;lt;=sWidth+width;i++){
            if (i%2==0){
                //凸弧
                mPath.quadTo(tmpX+width,y-height/2,tmpX+width*2,y);
            }else{
                //凹弧
                mPath.quadTo(tmpX+width,y+height/2,tmpX+width*2,y);
            }
            canvas.drawPath(mPath,mPaint);
            tmpX+=width*2;
            mPath.moveTo(tmpX,y);
        }
        if (isAnim){
            x-=width/10;
            if (x&amp;lt;=-width*4){
                x+=width*4;
            }
            invalidate();
        }

    }

    public void startAnim(boolean anim){
        isAnim=anim;
        invalidate();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Sat, 17 Sep 2016 00:00:00 +0800</pubDate>
        <link>http://mrrobot97.github.io/2016/09/17/%E5%88%A9%E7%94%A8%E4%BA%8C%E9%98%B6%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF%E7%BB%98%E5%88%B6%E5%8A%A8%E6%80%81%E6%B3%A2%E6%B5%AA.html</link>
        <guid isPermaLink="true">http://mrrobot97.github.io/2016/09/17/%E5%88%A9%E7%94%A8%E4%BA%8C%E9%98%B6%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF%E7%BB%98%E5%88%B6%E5%8A%A8%E6%80%81%E6%B3%A2%E6%B5%AA.html</guid>
        
        
      </item>
    
      <item>
        <title>ViewPager实现无限轮播</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;Android自带的ViewPager有翻页功能，支持用户手势滑动，但是不支持循环滚动，因此我们就在PagerAdapter的基础上为其增加循环滚动的功能就行了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;自定义Adapter继承自PagerAdapter，我们需要重写四个方法:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.public int getCount()
2.public Object instantiateItem(ViewGroup container, int position)
3.public boolean isViewFromObject(View view, Object object)
4.public void finishUpdate(ViewGroup container)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;假如我们有N个item需要循环滚动，那么在getCount中就返回2*N，这样让ViewPager以为我们有2N个page需要滚动，因此在滚动到第N页，即逻辑上的最后一页时，还能继续向后滚动，因为此时ViewPager以为后面还有N个page呢~&lt;/p&gt;

&lt;p&gt;在instantiateItem需要对position进行对N求模处理，毕竟我们实际上只有N个page，然后生成相应的View并添加到container中去：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Override
    public Object instantiateItem(ViewGroup container, int position) {
        position%=viewCnt;
        ViewGroup parent= (ViewGroup) mViews.get(position).getParent();
        if (parent!=null){
            parent.removeView(mViews.get(position));
        }
        container.addView(mViews.get(position));
        return mViews.get(position);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;isViewFromObject的写法是固定的:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Override
    public boolean isViewFromObject(View view, Object object) {
        return view==object;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后是finnishUpdate()方法，这个方法会在page切换完成之后调用，我们需要在这里实现page的偷偷替换：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Override
    public void finishUpdate(ViewGroup container) {
        super.finishUpdate(container);
        int position=mViewPager.getCurrentItem();
        if (position==0){
            //first pager,false to cancel translation
            mViewPager.setCurrentItem(viewCnt,false);
        }else if(position==getCount()-1){
            //last pager
            mViewPager.setCurrentItem(viewCnt-1,false);
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;之所以将第1个替换为第N+1个是因为第一个page无法向左滑动，而第N+1个左右滑动都可以，因为它左边是第N个，右面是第N+2个。同理将第2N个替换为第N个，因为第2N个无法向右滑动。&lt;/p&gt;

&lt;p&gt;因为替换的前后是同一个page的内容，并且我们的setCurrentItem()的第二个参数为false,即取消过渡动画，立即切换，因此用户不会感觉到page发生了切换。这样我们通过”暗度陈仓”，就实现了ViewPager的循环滚动。&lt;/p&gt;

&lt;p&gt;理论上我们还应该重写destroyItem()方法，但在我重写并在其中调用container.removeView(mViews.get(position))之后，发现在滚动的过程中会出现白屏现象，也没找到原因，反而注释这段代码之后正常了，知道原因的话请留言告诉我。&lt;/p&gt;

&lt;p&gt;Demo:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ockr1qfi1.bkt.clouddn.com/Screen%2520Capture%2520on%25202016-09-17%2520at%252015-51-54.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 17 Sep 2016 00:00:00 +0800</pubDate>
        <link>http://mrrobot97.github.io/2016/09/17/ViewPager%E5%AE%9E%E7%8E%B0%E6%97%A0%E9%99%90%E8%BD%AE%E6%92%AD.html</link>
        <guid isPermaLink="true">http://mrrobot97.github.io/2016/09/17/ViewPager%E5%AE%9E%E7%8E%B0%E6%97%A0%E9%99%90%E8%BD%AE%E6%92%AD.html</guid>
        
        
      </item>
    
      <item>
        <title>Android断点续传原理及实现</title>
        <description>&lt;p&gt;原理：利用HttpURLConnection进行从网站上下载文件时，我们可以利用HttpURLConnection的setRequestProperty()方法，对我们要读取的字节部分进行控制，比如:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.Range=0-100代表只读取前100个字节。
2.Range=100-500代表读取从第100个字节开始，读到第500个字节为止。
3.Range=100-则代表从第100个字节开始读取，一直读取到文件末尾结束。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样我们就可以轻松的实现对文件的各部分的读取了，我们只需要在暂停时记录一下已经读取到的位置，在重新开始的时候利用setRequestProperty()方法设置一下我们要读取的字节位置即可。&lt;/p&gt;

&lt;p&gt;这里还有一个问题就是我们应该怎样将读取到的字节流写入文件中，由于File是不支持在指定处写入字节的，因此我们这里要使用RandomAccessFile来进行字节流的写入，RandomAccessFile有一个方法seek(long)，允许我们指定要写入的位置。&lt;/p&gt;

&lt;p&gt;这样两者结合，就能够轻易的实现文件的断点续传了。&lt;/p&gt;

&lt;p&gt;多线程断点续传实现原理相同，只是利用多个线程同时下载，每个线程指定要下载的字节部分，写入到文件的指定部分。故这里只给出了单线程断点续传下载的实现部分：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class SingleDownloadTask{

        private String filePath;
        private int contentLength;
        private int readLength;
        private RandomAccessFile file=null;
         private boolean isPause=false;
        private URL url;

         public boolean isDownloading() {
             return isDownloading;
         }

         private boolean isDownloading=false;

        private Handler mHandler=new Handler();

        public SingleDownloadTask(String urlStr,String filePath) {
            this.filePath=filePath;
            readLength=0;
            contentLength=0;
            try {
                url=new URL(urlStr);
            } catch (MalformedURLException e) {
                e.printStackTrace();
            }
        }

        //download from pos
        public void download(){
            new Thread(new Runnable() {
                @Override
                public void run() {
                    isDownloading=true;
                    HttpURLConnection conn=null;
                    InputStream is=null;
                    BufferedInputStream bis=null;
                    try {
                        file=new RandomAccessFile(filePath,&quot;rw&quot;);
                        file.seek(readLength);
                        conn= (HttpURLConnection) url.openConnection();
                        if(readLength==0){
                            contentLength=conn.getContentLength();
                        }else{
                            conn.setRequestProperty(&quot;Range&quot;,&quot;bytes=&quot;+readLength+&quot;-&quot;);
                        }
                        is=conn.getInputStream();
                        bis=new BufferedInputStream(is);
                        byte[] bytes=new byte[1024];
                        int len=0;
                        while (!isPause&amp;amp;&amp;amp;((len=bis.read(bytes,0,1024)))!=-1){
                            file.write(bytes,0,len);
                            readLength+=len;
                            mHandler.post(new Runnable() {
                                @Override
                                public void run() {
                                    float rate=((float)readLength)/contentLength;
                                    mProgressBar.setProgress((int) (100*rate));
                                    mTextView.setText((int)(100*rate)+&quot;%&quot;);
                                }
                            });
                        }
                        isDownloading=false;
                        if (readLength&amp;gt;=contentLength){
                            mHandler.post(new Runnable() {
                                @Override
                                public void run() {
                                    Toast.makeText(MainActivity.this, &quot;文件下载成功,保存在&quot;+filePath
                                            , Toast.LENGTH_SHORT).show();
                                    mImageView.setImageBitmap(BitmapFactory.decodeFile(filePath));
                                }
                            });
                        }
                        file.close();
                    } catch (MalformedURLException e) {
                        e.printStackTrace();
                    } catch (IOException e) {
                        e.printStackTrace();
                    }finally {
                        if (bis!=null){
                            try {
                                bis.close();
                                if (is!=null){
                                    is.close();
                                }
                                if (conn!=null){
                                    conn.disconnect();
                                }
                            } catch (IOException e) {
                                e.printStackTrace();
                            }
                        }
                    }
                }
            }).start();
        }

        public void start(){
            isPause=false;
            download();
        }

        public void pause(){
            isPause=true;
        }

    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/mrrobot97/PauseDownload&quot;&gt;完整的Demo地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Demo:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ockr1qfi1.bkt.clouddn.com/2016-09-17_12_09_42.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 17 Sep 2016 00:00:00 +0800</pubDate>
        <link>http://mrrobot97.github.io/2016/09/17/Android%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0.html</link>
        <guid isPermaLink="true">http://mrrobot97.github.io/2016/09/17/Android%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0.html</guid>
        
        
      </item>
    
  </channel>
</rss>
