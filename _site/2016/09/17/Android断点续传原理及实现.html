<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="http://mrrobot97.github.io/stylesheets/stylesheet.css">
  <link rel="canonical" href="http://mrrobot97.github.io/2016/09/17/Android%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0.html">
  <link rel="alternate" type="application/rss+xml" title="mrrobot97's blog" href="http://mrrobot97.github.io/feed.xml">
  <meta name="description" content="原理：利用HttpURLConnection进行从网站上下载文件时，我们可以利用HttpURLConnection的setRequestProperty()方法，对我们要读取的字节部分进行控制，比如:">

   <title>Android断点续传原理及实现</title>



</head>


  <body>

    <header class="page-header">

	<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?"
     <h1 class="project-name"> <a class="header-link" href="/"> mrrobot97's blog</a></h1>
     <h3><a class="header-link" href="https://github.com/mrrobot97" target="_blank">follow me on github@mrrobot97</a></h3>
</header>


    <section class="main-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

    <div class="main-content" itemprop="articleBody">
  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Android断点续传原理及实现</h1>
   <p class="post-meta"><time datetime="2016-09-17T00:00:00+08:00" itemprop="datePublished">Sep 17, 2016</time> • <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">mrrobot97</span></span></p>
  </header>

    <p>原理：利用HttpURLConnection进行从网站上下载文件时，我们可以利用HttpURLConnection的setRequestProperty()方法，对我们要读取的字节部分进行控制，比如:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>1.Range=0-100代表只读取前100个字节。
2.Range=100-500代表读取从第100个字节开始，读到第500个字节为止。
3.Range=100-则代表从第100个字节开始读取，一直读取到文件末尾结束。
</code></pre>
</div>

<p>这样我们就可以轻松的实现对文件的各部分的读取了，我们只需要在暂停时记录一下已经读取到的位置，在重新开始的时候利用setRequestProperty()方法设置一下我们要读取的字节位置即可。</p>

<p>这里还有一个问题就是我们应该怎样将读取到的字节流写入文件中，由于File是不支持在指定处写入字节的，因此我们这里要使用RandomAccessFile来进行字节流的写入，RandomAccessFile有一个方法seek(long)，允许我们指定要写入的位置。</p>

<p>这样两者结合，就能够轻易的实现文件的断点续传了。</p>

<p>多线程断点续传实现原理相同，只是利用多个线程同时下载，每个线程指定要下载的字节部分，写入到文件的指定部分。故这里只给出了单线程断点续传下载的实现部分：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>class SingleDownloadTask{

        private String filePath;
        private int contentLength;
        private int readLength;
        private RandomAccessFile file=null;
         private boolean isPause=false;
        private URL url;

         public boolean isDownloading() {
             return isDownloading;
         }

         private boolean isDownloading=false;

        private Handler mHandler=new Handler();

        public SingleDownloadTask(String urlStr,String filePath) {
            this.filePath=filePath;
            readLength=0;
            contentLength=0;
            try {
                url=new URL(urlStr);
            } catch (MalformedURLException e) {
                e.printStackTrace();
            }
        }

        //download from pos
        public void download(){
            new Thread(new Runnable() {
                @Override
                public void run() {
                    isDownloading=true;
                    HttpURLConnection conn=null;
                    InputStream is=null;
                    BufferedInputStream bis=null;
                    try {
                        file=new RandomAccessFile(filePath,"rw");
                        file.seek(readLength);
                        conn= (HttpURLConnection) url.openConnection();
                        if(readLength==0){
                            contentLength=conn.getContentLength();
                        }else{
                            conn.setRequestProperty("Range","bytes="+readLength+"-");
                        }
                        is=conn.getInputStream();
                        bis=new BufferedInputStream(is);
                        byte[] bytes=new byte[1024];
                        int len=0;
                        while (!isPause&amp;&amp;((len=bis.read(bytes,0,1024)))!=-1){
                            file.write(bytes,0,len);
                            readLength+=len;
                            mHandler.post(new Runnable() {
                                @Override
                                public void run() {
                                    float rate=((float)readLength)/contentLength;
                                    mProgressBar.setProgress((int) (100*rate));
                                    mTextView.setText((int)(100*rate)+"%");
                                }
                            });
                        }
                        isDownloading=false;
                        if (readLength&gt;=contentLength){
                            mHandler.post(new Runnable() {
                                @Override
                                public void run() {
                                    Toast.makeText(MainActivity.this, "文件下载成功,保存在"+filePath
                                            , Toast.LENGTH_SHORT).show();
                                    mImageView.setImageBitmap(BitmapFactory.decodeFile(filePath));
                                }
                            });
                        }
                        file.close();
                    } catch (MalformedURLException e) {
                        e.printStackTrace();
                    } catch (IOException e) {
                        e.printStackTrace();
                    }finally {
                        if (bis!=null){
                            try {
                                bis.close();
                                if (is!=null){
                                    is.close();
                                }
                                if (conn!=null){
                                    conn.disconnect();
                                }
                            } catch (IOException e) {
                                e.printStackTrace();
                            }
                        }
                    }
                }
            }).start();
        }

        public void start(){
            isPause=false;
            download();
        }

        public void pause(){
            isPause=true;
        }

    }
</code></pre>
</div>

<p><a href="https://github.com/mrrobot97/PauseDownload">完整的Demo地址</a></p>

<p>Demo:</p>

<p><img src="http://ockr1qfi1.bkt.clouddn.com/2016-09-17_12_09_42.gif" alt="" /></p>

  </div>


<a href="http://mrrobot97.github.io"><h3 style="text-align: center;">- to blog -</h3></a>

<div id="disqus_thread"></div>
<script>
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = '//http-mrrobot97-me.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>


      </div>
    </div>

  </body>

    <!-- 背景特效 -->
    <script type="text/javascript">
      !function() {
    function o(w, v, i) {
        return w.getAttribute(v) || i
    }
    function j(i) {
        return document.getElementsByTagName(i)
    }
    function l() {
        var i = j("script"), w = i.length, v = i[w - 1];
        return {
            l: w,
            z: o(v, "zIndex", - 1),
            o: o(v, "opacity", 0.5),
            c: o(v, "color", "84,106,122"),
            n: o(v, "count", 70)
        }
    }
    function k() {
        r = u.width = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth, n = u.height = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight
    }
    function b() {
        e.clearRect(0, 0, r, n);
        var w = [f].concat(t);
        var x, v, A, B, z, y;
        t.forEach(function(i) {
            i.x += i.xa, i.y += i.ya, i.xa*=i.x > r || i.x < 0?-1 : 1, i.ya*=i.y > n || i.y < 0?-1 : 1, e.fillRect(i.x - 0.5, i.y - 0.5, 1, 1);
            for (v = 0; v < w.length; v++) {
                x = w[v];
                if (i !== x && null !== x.x && null !== x.y) {
                    B = i.x - x.x, z = i.y - x.y, y = B * B + z * z;
                    y < x.max && (x === f && y >= x.max / 2 && (i.x -= 0.03 * B, i.y -= 0.03 * z), A = (x.max - y) / x.max, e.beginPath(), e.lineWidth = A / 2, e.strokeStyle = "rgba(" + s.c + "," + (A + 0.2) + ")", e.moveTo(i.x, i.y), e.lineTo(x.x, x.y), e.stroke())
                }
            }
            w.splice(w.indexOf(i), 1)
        }), m(b)
    }
    var u = document.createElement("canvas"), s = l(), c = "c_n" + s.l, e = u.getContext("2d"), r, n, m = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(i) {
        window.setTimeout(i, 1000 / 45)
    }, a = Math.random, f = {
        x: null,
        y: null,
        max: 20000
    };
    u.id = c;
    u.style.cssText = "position:fixed;top:0;left:0;z-index:" + s.z + ";opacity:" + s.o;
    j("body")[0].appendChild(u);
    k(), window.onresize = k;
    window.onmousemove = function(i) {
        i = i || window.event, f.x = i.clientX, f.y = i.clientY
    }, window.onmouseout = function() {
        f.x = null, f.y = null
    };
    for (var t = [], p = 0; s.n > p; p++) {
        var h = a() * r, g = a() * n, q = 2 * a() - 1, d = 2 * a() - 1;
        t.push({
            x: h,
            y: g,
            xa: q,
            ya: d,
            max: 6000
        })
    }
    setTimeout(function() {
        b()
    }, 100)
}();
    </script>


    

</html>
